# üß† Prompt T√©cnico ALMA_LOADER v3.0

## üß≠ Roadmap T√©cnico ALMA_LOADER ‚Äì Versi√≥n Expandida

---

### üî∑ A. Roadmap T√©cnico por Capas (visi√≥n macro)

> Este esquema resume el camino del desarrollo de ALMA_LOADER en tres fases amplias, centradas en capacidades progresivas.

#### Fase 1 ‚Äì N√∫cleo estable (Core)
- Registro estructurado y validado (JSON Schema)
- Almacenamiento seguro en SQLite
- Cifrado de contenido sensible
- Generaci√≥n de res√∫menes y bit√°coras

#### Fase 2 ‚Äì IA Sem√°ntica
- Vectorizaci√≥n de contenido (FAISS + Embeddings)
- Router atencional para respuestas contextuales
- An√°lisis predictivo b√°sico
- Creaci√≥n de relaciones entre memorias

#### Fase 3 ‚Äì Expansi√≥n e Integraci√≥n
- Gamificaci√≥n y metas personales
- Sistema de reglas encadenadas (tipo "si X ‚Üí hacer Y")
- Conexi√≥n con aplicaciones externas: Telegram, Shortcuts, control por voz

---

### üî∑ B. Roadmap Operativo Detallado (vinculado al desarrollo actual)

> Esta secci√≥n detalla las tareas concretas, m√≥dulos activos y enlaces con los cuadernos digitales. Se actualiza por versi√≥n (actual: 3.0.3+).

#### üéØ Objetivo General

Consolidar un backend modular, seguro y ampliable que act√∫e como n√∫cleo inteligente de un asistente personal diario. Toda la l√≥gica y estructura se mantiene sintetizada en dos archivos base (`whitepaper` y `prompt t√©cnico`) para m√°xima claridad e interoperabilidad con modelos de lenguaje. Se prioriza compatibilidad con cuadernos digitales (Obsidian, Shortcuts, Recordatorios).

---

#### üîÅ Fase 1 ‚Äì Consolidaci√≥n del N√∫cleo
- Vectorizaci√≥n real con FAISS (`core/vector_storage.py`)
- GET `/v1/memorias`: recuperaci√≥n por texto, ID o tags
- Refactor de `sqlite_storage` (update, transacciones)
- Configuraci√≥n por `.env`
- Unificaci√≥n de estados (`Enum`)
- Actualizaci√≥n del whitepaper: ‚ÄúCore Engine v1‚Äù

---

#### üß† Fase 2 ‚Äì IA B√°sica y Consultas
- Endpoint `/v1/assistant/consultar`
- Uso de modelo externo para responder con contexto
- Creaci√≥n de `core/racionalizador.py`
- Prompts funcionales en el prompt t√©cnico
- Nueva secci√≥n: ‚ÄúCapas de interacci√≥n con IA‚Äù

---

#### üß© Fase 3 ‚Äì Integraci√≥n de M√≥dulos Tem√°ticos y Cuadernos

##### üìà Trading
- Endpoint `/v1/trading/resumen`
- Lectura de memorias ‚Äútrading‚Äù
- Enlace: Obsidian carpeta ‚ÄúTrading‚Äù, Recordatorios

##### üå± Cultivo
- Endpoint `/v1/cultivo/registro-datos`
- An√°lisis de VPD, EC, alertas
- Enlace: ‚Äú001_Flora‚Äù, ‚Äú002_Vege‚Äù

##### üíª Programaci√≥n
- Endpoint `/v1/code/consultar-snippet`
- Cuaderno digital: ‚ÄúProgramaci√≥n‚Äù

> Todos los m√≥dulos escriben y consultan memorias comunes bajo categor√≠as y tags.

---

#### üîê Fase 4 ‚Äì Seguridad y Despliegue
- JWT real y m√∫ltiples usuarios
- Dockerfile + `docker-compose`
- Endpoint de monitoreo b√°sico
- Telegram + Shortcuts como interfaz liviana

---

#### üîÑ Fase 5 ‚Äì Sincronizaci√≥n con Cuadernos Digitales
- Carga autom√°tica desde notas Obsidian (por tags)
- Registro de Recordatorios diarios como memorias
- Mapa de relaciones con grafo (D3.js o Neo4j)
- Nueva secci√≥n: ‚ÄúMemoria extendida‚Äù en whitepaper

---

#### üìò Notas Finales
- Toda evoluci√≥n queda registrada en el `CHANGELOG.md`
- Se prioriza siempre claridad conceptual antes que escalamiento t√©cnico
## 1. Prop√≥sito del Sistema
Este prompt define todas las funciones t√©cnicas, estructuras internas y flujos de interacci√≥n del sistema ALMA_LOADER. Su objetivo es que cualquier modelo IA o humano t√©cnico pueda ejecutar, extender o auditar el sistema con claridad total. Consolidado a partir de versiones 2.1.1 y 2.2.0.
El Prompt T√©cnico: **‚Äúenfoque t√©cnico y operacional‚Äù**
Para la perspectiva emocional y filos√≥fica del sistema, ver el Pr√≥logo del Whitepaper.‚Äù
> üìò Para entender el prop√≥sito humano, los casos de uso y la visi√≥n general del sistema,  
> consult√° el [Whitepaper de ALMA_LOADER](ALMA_LIBRE/MODULOS/Alma_Loader/alma_loader_v3.0.3/docs/archivos_fundamentales/whitepaper_ALMA_LOADER_v3.0.2.md)

## 2. M√≥dulos Funcionales
- `core_nl.py` ‚Äì Conversi√≥n NL ‚Üí JSON mediante reglas y patrones
- `validador.py` ‚Äì Validaci√≥n con `schema_base.json` y normalizaci√≥n de campos
- `sqlite_storage.py` ‚Äì Almacenamiento actual, optimizado con JSON1 para consultas internas
- `base_storage.py` ‚Äì Interfaz abstracta de almacenamiento compatible con m√∫ltiples motores
- `vector_storage.py` ‚Äì B√∫squeda sem√°ntica con embeddings v√≠a FAISS (alpha)
- `router_atencional.py` ‚Äì Enrutamiento seg√∫n intenci√≥n detectada (acci√≥n, reflexi√≥n, memoria)
- `resumenes.py` ‚Äì Generaci√≥n de resumen en Markdown diario o semanal
- `alma_analytics.py` ‚Äì Detecci√≥n de patrones, correlaciones y disparadores
- `gamificacion.py` ‚Äì Sistema de motivaci√≥n por puntos, niveles y h√°bitos (fase 3)

Los m√≥dulos de ALMA_LOADER est√°n dise√±ados para ser independientes y f√°cilmente intercambiables. A continuaci√≥n, se indican las principales tecnolog√≠as asociadas a cada uno:

### üõ†Ô∏è Tecnolog√≠as Utilizadas por M√≥dulo

| M√≥dulo                   | Tecnolog√≠a / Herramienta              |
|--------------------------|--------------------------------------|
| NLP / Parsing            | `regex`, `spaCy` (plan futuro)       |
| Vectorizaci√≥n sem√°ntica | `sentence-transformers`, `FAISS`     |
| Almacenamiento           | `SQLite` (con JSON1), `FAISS` (alpha)|
| Visualizaci√≥n / Testing  | `pytest`, `Mermaid` (para diagramas) |
| Relaciones sem√°nticas    | `dict`, relaciones cruzadas (`Neo4j`, `networkx` ‚Äì futuro) |


## 3. JSON Schema de Memoria
```json
{
  "id": "MEM-TRD-2025-XXXX",
  "categoria": "TRD",
  "contenido": "texto plano",
  "tags": ["#btc", "#reflexi√≥n"],
  "resumen_inferido": "...",
  "embedding_id": "EMB-abc123",
  "vector": [0.123, 0.987, ...],
  "intencion_detectada": "registro",
  "origen_input": "usuario",
  "relaciones": [
    { "tipo": "temporal", "target_id": "MEM-TRD-2025-XXXX", "peso": 0.8 }
  ]
}
```

---
### 3.1 Convenci√≥n de IDs y Versionado de Memorias

Cada memoria debe contar con un `id` √∫nico, que permita trazabilidad, orden temporal, y segmentaci√≥n por tipo. Recomendamos el siguiente formato:

```
MEM-[TIPO]-[YYYY]-[MM]-[DD]-[NNN]
```

### üìÑ Ejemplo:
```
MEM-TRD-2025-05-06-001
```

- `TRD` ‚Üí categor√≠a o m√≥dulo (ej: TRD, EMO, SYS)
- `2025-05-06` ‚Üí fecha
- `001` ‚Üí n√∫mero incremental del d√≠a (o sesi√≥n)

Esta convenci√≥n permite:
- Identificar r√°pidamente tipo y fecha
- Ordenar cronol√≥gicamente sin DB externa
- Evitar colisiones entre memorias en sistemas distribuidos
- Agrupar y filtrar eficientemente

> Puede extenderse a subtipos si es necesario: `MEM-TRD-BTC-2025-05-06-001`
## 4. Interfaces y Abstracciones
- `BaseStorage`: permite intercambiar SQLite por FAISS, Neo4j u otros sin modificar el flujo general
- `router_atencional`: enruta el input al m√≥dulo correcto seg√∫n an√°lisis r√°pido de intenci√≥n

## 5. Flujo Conversacional Esperado
El flujo completo del sistema est√° ilustrado conceptualmente en el Whitepaper, Secci√≥n 4.
## 6. Automatizaciones
- Generaci√≥n diaria/semanal de res√∫menes en Markdown
- Backups autom√°ticos del `memorias.db` o vector_index
- Alertas sem√°nticas seg√∫n `reglas_dinamicas.json`

ALMA_LOADER puede aplicar reglas condicionales para responder a patrones en las memorias registradas. Estas reglas se definen en `reglas_dinamicas.json`.

### üìÑ Ejemplo real:

```json
{
  "si": ["#sobreoperaci√≥n", "#fatiga"],
  "entonces": "Sugerir MEMHEALTH-022 y reducir riesgo al 1%"
}
```

Este tipo de l√≥gica permite que el sistema detecte condiciones problem√°ticas combinadas y act√∫e en consecuencia, ya sea sugiriendo contenidos previos, modificando recomendaciones, o generando alertas.

> Estas reglas son interpretadas por `alma_analytics.py` y se pueden expandir din√°micamente.

## 7. Coexistencia entre SQLite y FAISS

ALMA_LOADER permite almacenar una misma memoria en dos lugares distintos con funciones complementarias:

- **SQLite** ‚Üí estructura completa legible, campos validados y utilizables para res√∫menes, etiquetas, temporalidad.
- **FAISS** ‚Üí vector num√©rico del contenido, usado para b√∫squedas sem√°nticas (por similitud de significado).

Para mantener la sincronizaci√≥n entre ambas capas, se utiliza un campo com√∫n: `embedding_id`.

### üîó Ejemplo de v√≠nculo:
```json
{
  "id": "MEM-TRD-2025-05-06-001",
  "embedding_id": "EMB-65fabc9271c1",
  ...
}
```

- Ese `embedding_id` act√∫a como **clave externa l√≥gica**: permite que, al hacer una b√∫squeda en FAISS, se pueda recuperar el ID original de SQLite.
- Esto permite mantener bajo control los metadatos (`tags`, `intenci√≥n`, `resumen`, etc.) y los vectores (`vector`) por separado, pero relacionados.

> ‚ö†Ô∏è Toda memoria que se vectorice debe tener su `embedding_id` registrado en ambos lados. Esto garantiza trazabilidad completa en b√∫squedas sem√°nticas, an√°lisis y visualizaciones futuras.
## 8. Instrucciones de Integraci√≥n
- Todo input debe ser procesado con `core_nl.py`
- Las memorias deben validarse contra `schema_base.json`
- Toda salida debe ser JSON v√°lido, o Markdown estructurado si es resumen
- DeepSeek, GPT o terminales pueden interactuar directamente con cada m√≥dulo

---
> Este prompt t√©cnico permite que cualquier IA ejecute acciones correctas dentro de ALMA_LOADER sin ambig√ºedades ni errores de interpretaci√≥n. Complementa al whitepaper 3.0 (explicativo y estrat√©gico).

## 9. Testing y Validaciones

### üß™ Test Unitario ‚Äì Validaci√≥n de Memoria

Este test permite verificar que el esquema base JSON acepte estructuras v√°lidas y rechace incorrectas. Se usa como prueba m√≠nima para `validador.py`.

```python
def test_validar_memoria():
    memoria_valida = {
        "id": "MEM-TRD-2025-05-06-001",
        "categoria": "TRD",
        "contenido": "Hoy oper√© en BTC y me sent√≠ confiado",
        "tags": ["#btc", "#emoci√≥n:confianza"]
    }
    assert validar_esquema(memoria_valida) == True
```

Este tipo de test puede ejecutarse con `pytest`, `unittest`, o integrarse en un pipeline de verificaci√≥n previa al guardado.

### üß™ Test Unitario ‚Äì Vectorizaci√≥n Sem√°ntica

Este test valida que la funci√≥n de embeddings est√© operativa y produzca un vector v√°lido (usualmente de 384 o 768 dimensiones, seg√∫n modelo).

```python
def test_vectorizacion():
    texto = "Hoy oper√© bajo presi√≥n y me sent√≠ impulsivo."
    vector = generar_embedding(texto)
    
    assert isinstance(vector, list)
    assert len(vector) >= 128
    assert all(isinstance(x, float) for x in vector)
```

> Este test puede servir tanto para debug local como para verificar integridad del motor FAISS en producci√≥n.

## 10. Relaciones entre Memorias ‚Äì Grafo Dirigido

ALMA_LOADER permite establecer v√≠nculos expl√≠citos entre memorias usando el campo `relaciones`. Esto habilita un grafo dirigido de conocimiento interno.

Cada relaci√≥n incluye:
- `tipo`: naturaleza de la relaci√≥n (ej: `temporal`, `causal`, `emocional`, `refuerzo`)
- `target_id`: ID de la memoria relacionada
- `peso`: valor entre 0 y 1 que indica la fuerza del v√≠nculo

### üìÑ Ejemplo:
```json
"relaciones": [
  { "tipo": "causal", "target_id": "MEM-TRD-2025-05-04-002", "peso": 0.85 },
  { "tipo": "temporal", "target_id": "MEM-TRD-2025-05-03-001", "peso": 0.6 }
]
```

Este grafo puede analizarse para:
- Descubrir patrones encadenados (causas ‚Üí consecuencias)
- Medir recurrencia o acumulaci√≥n emocional
- Visualizar el recorrido mental de un tema

### üõ†Ô∏è Futuras integraciones:
- `networkx` (Python) para an√°lisis de grafos
- `Neo4j` para persistencia de relaciones complejas
- Mermaid o D3.js para visualizaci√≥n gr√°fica

> El objetivo es pasar de registros aislados a una red din√°mica de aprendizaje personal.

## üîå Integraci√≥n con M√≥dulos Externos

ALMA_LOADER est√° dise√±ado para operar como n√∫cleo de memoria e inteligencia sem√°ntica para m√∫ltiples aplicaciones.

Esta versi√≥n 3.0.2 introduce una estructura preparada para la futura integraci√≥n de m√≥dulos externos. Cada uno de estos m√≥dulos podr√° interactuar con el sistema a trav√©s de sus interfaces y funciones expuestas.

### Ejemplos de m√≥dulos potenciales (en evaluaci√≥n):
- üìä Analizador de Trading Emocional
- üå± Gestor Inteligente de Cultivo
- üìî Bit√°cora Personal Automatizada
- üß† Asistente de Decisiones Estrat√©gicas
- üí∞ Controlador de Fondos y Riesgo

> En futuras versiones, cada m√≥dulo tendr√° su documentaci√≥n (`README`) y prompt local, conectado a ALMA_LOADER como backend de memoria.

Esta secci√≥n ser√° actualizada a medida que se confirmen las integraciones.