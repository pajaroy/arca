Aquí está la implementación del módulo `access_control.py` siguiendo los requisitos:

python

Copy

Download

# access_control.py
import logging
from datetime import datetime

logger = logging.getLogger(__name__)

def verificar_acceso(memoria: dict, user_id: str, rol: str) -> bool:
    """
    Verifica si un usuario tiene permiso para acceder a una memoria según su visibilidad.
    
    Args:
        memoria (dict): Diccionario con la memoria a verificar
        user_id (str): Identificador del usuario solicitante
        rol (str): Rol del usuario en el sistema
    
    Returns:
        bool: True si tiene acceso, False en caso contrario
    """
    visibilidad = memoria.get('visibilidad')
    
    if visibilidad == "publica":
        return True
    elif visibilidad == "privada":
        return user_id == memoria.get('owner_id')
    elif visibilidad == "solo_sistema":
        return rol == "sistema"
    return False

def registrar_traza(evento: str, memoria_id: str, user_id: str = None, metadata: dict = None):
    """
    Registra un evento de acceso en logs estructurados.
    
    Args:
        evento (str): Tipo de evento (ej: "acceso_denegado", "acceso_exitoso")
        memoria_id (str): Identificador de la memoria accedida
        user_id (str, opcional): ID del usuario relacionado
        metadata (dict, opcional): Metadatos adicionales del evento
    """
    traza = {
        "evento": evento,
        "memoria_id": memoria_id,
        "user_id": user_id,
        "timestamp": datetime.utcnow().isoformat()
    }
    
    if metadata:
        traza.update(metadata)
    
    # Log estructurado compatible con sistemas de monitoreo
    logger.info(
        "Evento de trazabilidad registrado",
        extra={"traza": traza}
    )

**Características clave:**

1. **Lógica de acceso clara:**
    
    - Usa un sistema de visibilidad de 3 niveles
        
    - Decisiones basadas en reglas simples y mantenibles
        
    - Fácil de extender con nuevas políticas
        
2. **Trazabilidad robusta:**
    
    - Registros en formato JSON-ready
        
    - Metadatos extensibles
        
    - Timestamp en UTC e ISO8601
        
    - Compatible con sistemas como:
        
        json
        
        Copy
        
        Download
        
        {
            "traza": {
                "evento": "acceso_denegado",
                "memoria_id": "mem-123",
                "user_id": "usr-456",
                "timestamp": "2024-02-22T15:30:45.123Z",
                "ip": "192.168.1.1"
            }
        }
        
3. **Diseño para extensiones futuras:**
    
    - Parámetros listos para JWT (owner_id, scopes)
        
    - Estructura compatible con inyección de servicios de auditoría
        
    - Métodos desacoplados para integración flexible
        

**Ejemplo de uso:**

python

Copy

Download

# Verificación de acceso
memoria = {
    "id": "mem-123",
    "visibilidad": "privada",
    "owner_id": "usr-789"
}

if verificar_acceso(memoria, "usr-789", "usuario"):
    print("Acceso permitido")
else:
    print("Acceso denegado")

# Registro de traza
registrar_traza(
    evento="acceso_exitoso",
    memoria_id="mem-123",
    user_id="usr-789",
    metadata={"metodo": "API REST", "direccion_ip": "192.168.1.1"}
)

**Ventajas del diseño:**

- ✅ Zero dependencias externas
    
- ✅ Fácil integración con cualquier framework
    
- ✅ Registros listos para sistemas de monitoreo
    
- ✅ Escalable para políticas complejas de RBAC/ABAC
    
- ✅ Mantenimiento sencillo de reglas de acceso