---
module: lecciones_aprendidas
type: core
status: in_progress
created: '2025-05-22'
linked_to:
- metodologia_doc_ia_v2.md

---
# ğŸ§  Lecciones Aprendidas â€“ ALMA_RESIST

ğŸ“ VersiÃ³n: 0.0.0.1  
ğŸ“… Ãšltima actualizaciÃ³n: 2025-05-20  
ğŸ‘¤ Responsable: Usuario + IA

---

## Sprint 1 â€“ Logging (2025-05-17)

- Validar tipos de eventos garantiza integridad de la estructura.
- La escritura atÃ³mica evita corrupciÃ³n ante fallas de energÃ­a.
- El uso de `ensure_ascii=False` mejora compatibilidad con caracteres especiales.
- La inclusiÃ³n de metadatos del sistema facilita el diagnÃ³stico offline.
- Es mejor usar `"n/a"` como valor por defecto cuando el hostname no es confiable.

## Sprint 1 â€“ Logging (Subtarea 2) â€“ Cifrado Funcional (2025-05-17)

- ğŸ“Œ El cifrado AES-GCM requiere cuidado con los offsets binarios (header exacto de 4 bytes).
- ğŸ“Œ El `nonce` debe tener longitud de 12 bytes, no se debe asumir longitud de lectura.
- ğŸ“Œ El uso de encabezados binarios (`b"AES\x00"`) permite detecciÃ³n rÃ¡pida del algoritmo.
- ğŸ“Œ Leer 8 bytes donde sÃ³lo hay 4 puede corromper el flujo de descifrado: bug crÃ­tico detectado.
- âœ… Se confirmÃ³ que PyCryptodome maneja bien el fallback a ChaCha20 si no hay AES-NI.

---

## Sprint 2 â€“ AuditorÃ­a TÃ©cnica y Estructura Inicial (2025-05-20)

- ğŸ“ Toda auditorÃ­a debe quedar documentada en un archivo `auditoria_estructura.md`.
- ğŸ“Œ El Ã¡rbol de carpetas es tan importante como el cÃ³digo: auditable y coherente.
- âŒ Se identificaron malas prÃ¡cticas como `archivos/` genÃ©rica â†’ eliminar o renombrar siempre.
- âœ… Estandarizar los logs, los prompts, los tests y los changelogs como secciones separadas evita caos futuro.
- âœ… Las tareas deben derivar de checklists claras (`checklist_auditoria_inicial.md`) y tener trazabilidad en `hitos.md`.

---

## Sprint 2 â€“ Gobernanza y Control de Versiones (2025-05-20)

- âœ… Las versiones deben mantenerse vivas (`hitos.md`) pero congelarse cuando cambian fases.
- ğŸ“Œ Una carpeta `/docs/versiones/` bien organizada facilita rollback, auditorÃ­a y revisiÃ³n externa.
- ğŸ“Œ Cada versiÃ³n debe tener su propio changelog, hitos y resumen MVP al momento de cierre.
- âœ… El `changelog.md` debe registrarse por versiÃ³n, no como log desordenado de cambios sueltos.

---

## Sprint 2 â€“ DocumentaciÃ³n y NavegaciÃ³n Obsidian (2025-05-20)

- âœ… Usar `[[enlaces]]` en vez de rutas duras (`/docs/...`) permite navegaciÃ³n semÃ¡ntica y grafo Obsidian.
- âœ… Separar las carpetas por propÃ³sito (`mvp/`, `auditorias/`, `checklists/`, `versiones/`) reduce fricciÃ³n mental.
- ğŸ“Œ Tener un `index.md` desde el principio es esencial, incluso si es mÃ­nimo: actÃºa como cerebro del sistema.

---

## Sprint 3 â€“ Lecciones de AuditorÃ­a TÃ©cnica (2025-05-20)

### ğŸ“š Estructura y DocumentaciÃ³n

- âœ… La incorporaciÃ³n del paso 0 (planificaciÃ³n por checklist) mejora radicalmente la trazabilidad y evita ejecuciÃ³n sin direcciÃ³n.
- âœ… El uso de `tree` para capturar la estructura real facilita auditorÃ­as futuras y control de integridad de carpetas.
- âœ… Las plantillas internas (`checklist`, `prompt`, `post-mortem`, etc.) aceleran el desarrollo manteniendo estÃ¡ndares.

### ğŸ§  Gobernanza y Trazabilidad

- âœ… Registrar cada bloque en `hitos.md`, `changelog.md`, y `lecciones_aprendidas.md` solo al final del sprint evita ruido documental innecesario.
- âœ… El concepto de â€œbloque cerradoâ€ permite agrupar cambios sin contaminar el resumen MVP ni los logs tÃ©cnicos dÃ­a a dÃ­a.

### ğŸ—‚ï¸ Estructura semÃ¡ntica

- âœ… Integrar referencias tÃ©cnicas externas (`docs/referencias/externas/`) separa bien la inspiraciÃ³n de la implementaciÃ³n.
- âœ… Tener una Ãºnica `idea_base.md` activa mejora la claridad general del proyecto y evita contradicciones con versiones anteriores.
---

## Sprint 4 â€“ CLI Modular (2025-05-20)

### ğŸ§  Lecciones clave

- âŒ `cmd.Cmd` no es adecuado para arquitecturas modulares: su introspecciÃ³n depende de mÃ©todos definidos en clase, no permite escalar por archivos.
- âœ… Separar comandos en funciones `run(args)` por archivo mejora mantenimiento, testing y extensiÃ³n.
- âœ… Construir un router CLI propio permite mayor control, logging, ayuda dinÃ¡mica y robustez.
- âœ… Agregar logs desde el principio (nivel `INFO`, `WARNING`, `ERROR`) permite auditar uso real del sistema y preparar futuros modelos de autoajuste.
- âœ… Mantener el `README.md` del mÃ³dulo actualizado con ejemplos y comandos vÃ¡lidos ayuda al onboarding tÃ©cnico futuro.
---
### 2025-05-21 â€“ FormalizaciÃ³n de la metodologÃ­a de estructura modular v2
- Se adoptÃ³ como estÃ¡ndar oficial la versiÃ³n 2 tras validaciÃ³n externa y revisiÃ³n crÃ­tica.
- Se elimina el uso de `versionado/`, se refuerzan convenciones, y se integran bloques YAML semÃ¡nticos para IA.

---
## ğŸ“˜ Sprint 2.2 â€“ MetodologÃ­as Base

ğŸ§  Lecciones aprendidas:
- Definir reglas claras desde el inicio facilita enormemente la integraciÃ³n futura de mÃ³dulos.
- Es mÃ¡s eficiente trabajar con plantillas y convenciones unificadas que improvisar por sprint.
- Documentar con metadatos YAML permite que la IA navegue, sugiera y valide sin intervenciÃ³n constante.
- Separar propuestas, versiones y archivos activos da orden visual y mental al operador Ãºnico.
---
## Sprint 2.3 â€“ CorrecciÃ³n de Metadatos

- La automatizaciÃ³n temprana reduce errores humanos y acelera el ritmo del proyecto.
- Las validaciones estrictas de `validate_docs.py` obligan a mantener la integridad semÃ¡ntica.
- El uso de `snake_case` en los mÃ³dulos mejora la interoperabilidad futura con IA.
- Integrar validaciÃ³n y normalizaciÃ³n como pasos estÃ¡ndar de agregado es clave para la escalabilidad.
- Documentar bien los procesos permite enfocarse en lo importante y facilita delegaciÃ³n futura.

---

### ğŸ“˜ Sprint 2.1 â€“ ProfesionalizaciÃ³n de la Estructura Documental (2025-05-23)

#### âœ… Lo que funcionÃ³

- Consolidar una estructura documental modular (`docs/`, `testing/`, `estructura_doc/`) agilizÃ³ la gestiÃ³n del proyecto.
    
- Automatizar la validaciÃ³n de metadatos (`test_metadata.py`) mejorÃ³ la trazabilidad y redujo errores humanos.
    
- Implementar plantillas con frontmatter estandarizado permitiÃ³ avanzar hacia interoperabilidad IA sin fricciÃ³n.
    
- Incluir `TODO.md` y `.project.md` facilitÃ³ el seguimiento vivo del estado del sistema.
    

#### âš ï¸ Lo que se puede mejorar

- Incluir metadatos desde el inicio en todos los documentos evitarÃ­a ciclos de correcciÃ³n posteriores.
    
- Estandarizar la nomenclatura y formato de carpetas (`/resgistros/` vs `/registros/`) deberÃ­a aplicarse antes de integrar archivos nuevos.
    

#### ğŸ§  Aprendizaje estratÃ©gico

- Documentar con estructura semÃ¡ntica desde el Sprint 2.1 sienta las bases para IA con reflexiÃ³n y navegaciÃ³n futura.
    
- La combinaciÃ³n de control de versiones, testing, documentaciÃ³n viva y hashing de snapshots crea un sistema auditable y antifrÃ¡gil.
    

---

### ğŸ“˜ Sprint 2.3 â€“ IntegraciÃ³n de Idea Base Unificada (2025-05-23)

#### âœ… Lo que funcionÃ³

- Consolidar mÃºltiples fuentes conceptuales en un solo documento (`idea_base_unificada.md`) eliminÃ³ ambigÃ¼edad y redundancia.
    
- Archivar versiones anteriores en `_legacy/` mantuvo trazabilidad sin contaminar la versiÃ³n activa.
    
- AcompaÃ±ar la integraciÃ³n con `README.md`, `version.md` y `changelog.md` facilitÃ³ el versionado humano y tÃ©cnico.
    
- Documentar el flujo como metodologÃ­a (`metodologia_agregado_archivos.md`) sienta base para integraciones futuras reproducibles.
    

#### âš ï¸ Lo que se puede mejorar

- Automatizar el archivado y validaciÃ³n de metadatos ahorrarÃ­a tiempo manual.
    
- Incluir el registro de hash o tag en el momento de la integraciÃ³n evitarÃ­a omisiones posteriores.
    

#### ğŸ§  ReflexiÃ³n clave

Este sprint demostrÃ³ que incluso ideas complejas y divergentes pueden unificarse de forma coherente cuando se aplica una metodologÃ­a disciplinada.

---
## ğŸ§  LecciÃ³n Aprendida - Sprint 2.4

- La validaciÃ³n semÃ¡ntica (`linked_to`, `domain`, `tags`) es crÃ­tica y debe automatizarse desde el principio.
- Separar reglas de validaciÃ³n en archivos independientes mejora la trazabilidad del conocimiento.
- El uso de scripts como `add_linked_to_minimo.py` y `alma-cli.py` redujo significativamente el trabajo manual.
- Es fundamental definir claramente cuÃ¡ndo se requiere quÃ© metadato en cada tipo de documento (`type`).
