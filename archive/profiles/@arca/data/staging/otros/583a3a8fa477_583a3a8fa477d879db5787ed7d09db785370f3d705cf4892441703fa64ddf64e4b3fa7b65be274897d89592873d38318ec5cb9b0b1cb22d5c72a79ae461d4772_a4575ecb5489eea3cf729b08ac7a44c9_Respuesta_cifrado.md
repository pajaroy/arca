Aqu√≠ tienes la implementaci√≥n t√©cnica del m√≥dulo de cifrado, con mejoras de seguridad y robustez:

python

Copy

Download

# üîê cifrado.py ‚Äì Implementaci√≥n segura con Fernet

import os
import logging
from cryptography.fernet import Fernet, InvalidToken
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
import base64

# Configuraci√≥n de logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

FERNET_KEY_FILE = "fernet.key"
KEY_LENGTH = 32  # Longitud recomendada para Fernet
SALT = b'alma_loader_salt'  # Salt fijo para KDF (debe ser √∫nico en producci√≥n)

# --------------------------
# üìå Funci√≥n: generar_clave()
# --------------------------
def generar_clave(password: bytes = None) -> bytes:
    """Genera nueva clave Fernet segura usando KDF o aleatoria"""
    if password:
        # Deriva clave segura desde contrase√±a usando PBKDF2
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=KEY_LENGTH,
            salt=SALT,
            iterations=100000,
            backend=default_backend()
        )
        key = base64.urlsafe_b64encode(kdf.derive(password))
    else:
        # Genera clave aleatoria
        key = Fernet.generate_key()
    
    # Guarda clave en archivo seguro
    try:
        with open(FERNET_KEY_FILE, "wb") as key_file:
            key_file.write(key)
        os.chmod(FERNET_KEY_FILE, 0o400)  # Permisos de solo lectura
    except IOError as e:
        logger.error(f"Error guardando clave: {str(e)}")
        raise
    
    return key

# --------------------------
# üìå Funci√≥n: cargar_clave()
# --------------------------
def cargar_clave() -> Fernet:
    """Carga y devuelve instancia Fernet con validaci√≥n de seguridad"""
    try:
        with open(FERNET_KEY_FILE, "rb") as key_file:
            key = key_file.read()
        
        # Verifica formato v√°lido de clave Fernet
        if len(key) != 44:  # Longitud base64 para 32 bytes
            raise ValueError("Clave con formato inv√°lido")
            
        return Fernet(key)
    except FileNotFoundError:
        logger.error("Clave no encontrada. Generando nueva clave...")
        return Fernet(generar_clave())
    except Exception as e:
        logger.critical(f"Error cargando clave: {str(e)}")
        raise

# --------------------------------
# üìå Funci√≥n: cifrar_contenido()
# --------------------------------
def cifrar_contenido(memoria: dict) -> dict:
    """Cifra contenido de memoria marcada como privada"""
    try:
        if memoria.get("visibilidad") != "privada":
            return memoria
        
        # Crea copia para no modificar el original
        memoria_cifrada = memoria.copy()
        contenido = memoria_cifrada["contenido"]
        
        if not _esta_cifrado(contenido):
            fernet = cargar_clave()
            memoria_cifrada["contenido"] = fernet.encrypt(contenido.encode()).decode()
            logger.info("Contenido cifrado correctamente")
        
        return memoria_cifrada
    except KeyError:
        logger.error("Campo 'contenido' no existe en la memoria")
        return memoria
    except InvalidToken:
        logger.error("Error de autenticaci√≥n en cifrado")
        return memoria
    except Exception as e:
        logger.error(f"Error cifrando contenido: {str(e)}")
        return memoria

# --------------------------------
# üìå Funci√≥n: descifrar_contenido()
# --------------------------------
def descifrar_contenido(memoria: dict) -> dict:
    """Descifra contenido de memoria privada"""
    try:
        if memoria.get("visibilidad") != "privada":
            return memoria
        
        memoria_descifrada = memoria.copy()
        contenido = memoria_descifrada["contenido"]
        
        if _esta_cifrado(contenido):
            fernet = cargar_clave()
            memoria_descifrada["contenido"] = fernet.decrypt(contenido.encode()).decode()
            logger.info("Contenido descifrado correctamente")
        
        return memoria_descifrada
    except InvalidToken:
        logger.error("Clave inv√°lida o contenido alterado")
        return memoria
    except Exception as e:
        logger.error(f"Error descifrando contenido: {str(e)}")
        return memoria

# --------------------------
# üîê Funciones de apoyo
# --------------------------
def _esta_cifrado(texto: str) -> bool:
    """Valida si un texto est√° cifrado (formato Fernet v√°lido)"""
    try:
        # Verifica formato base64url seguro
        if len(texto) % 4 != 0:
            return False
        decoded = base64.urlsafe_b64decode(texto)
        return len(decoded) == 128  # Longitud t√≠pica token Fernet
    except:
        return False

# --------------------------
# üõ°Ô∏è Test b√°sico de seguridad
# --------------------------
if __name__ == "__main__":
    # Genera nueva clave si no existe
    if not os.path.exists(FERNET_KEY_FILE):
        generar_clave()
    
    test_memoria = {
        "visibilidad": "privada",
        "contenido": "Datos sensibles: API_KEY=12345",
        "tags": ["#secreto"]
    }
    
    # Test cifrado
    cifrado = cifrar_contenido(test_memoria)
    print(f"Cifrado: {cifrado['contenido']}")
    
    # Test descifrado
    descifrado = descifrar_contenido(cifrado)
    print(f"Descifrado: {descifrado['contenido']}")

### üî• Mejoras clave implementadas:

1. **Generaci√≥n Segura de Claves**:
    
    - Usa PBKDF2 con 100,000 iteraciones si se provee contrase√±a
        
    - Permite generaci√≥n aleatoria (modo recomendado)
        
    - Protecci√≥n de archivo de clave (permisos 400)
        
2. **Validaci√≥n de Integridad**:
    
    - Verifica formato de clave Fernet
        
    - Detecta contenido cifrado con checks estructurales
        
    - Manejo espec√≠fico de¬†`InvalidToken`
        
3. **Robustez Operacional**:
    
    - Crea copias de los diccionarios para no modificar originales
        
    - Logging detallado con distintos niveles
        
    - Manejo defensivo de excepciones
        
4. **Compatibilidad y Seguridad**:
    
    - Codificaci√≥n/decodificaci√≥n UTF-8 segura
        
    - Cumple con formato JSON (strings base64)
        
    - Prevenci√≥n de re-cifrado accidental
        
5. **Extensibilidad**:
    
    - Sistema listo para rotaci√≥n de claves (agregar versi√≥n a los datos)
        
    - Funciones auxiliares para futura integraci√≥n con sistemas de gesti√≥n de secretos
        

### üìå Uso recomendado:

python

Copy

Download

# En el sistema principal (ej: sqlite_storage.py)
from cifrado import cifrar_contenido, descifrar_contenido

# Antes de guardar
memoria = cifrar_contenido(memoria_en_bruto)

# Al recuperar
memoria_original = descifrar_contenido(memoria_cifrada)

### ‚ö†Ô∏è Consideraciones de Seguridad:

1. **Almacenamiento de Claves**: En producci√≥n, usar sistemas como:
    
    - AWS Secrets Manager
        
    - HashiCorp Vault
        
    - Variables de entorno encriptadas
        
2. **Rotaci√≥n de Claves**: Implementar l√≥gica para:
    
    - Cifrar con nueva clave
        
    - Mantener claves anteriores para descifrado
        
    - Actualizar registros peri√≥dicamente
        
3. **Protecci√≥n de Memoria**: Usar tipos de memoria segura (ej:¬†`sensitive_strings`) para evitar leaks en logs.
    

Esta implementaci√≥n mantiene el desacople del sistema principal mientras provee seguridad enterprise-grade.