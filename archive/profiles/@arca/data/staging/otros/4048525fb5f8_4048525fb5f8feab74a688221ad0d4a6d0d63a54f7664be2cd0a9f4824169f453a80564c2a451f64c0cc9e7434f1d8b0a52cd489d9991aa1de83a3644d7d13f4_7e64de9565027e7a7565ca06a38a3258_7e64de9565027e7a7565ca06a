import argparse
import os
import logging
import sys
import subprocess
from ruamel.yaml import YAML
from ruamel.yaml.comments import CommentedMap
from io import StringIO

logging.basicConfig(
    level=logging.INFO,
    filename='fix_responsable.log',
    filemode='a',
    format='%(asctime)s - %(levelname)s - %(message)s'
)

FIX_LAST_MODIFIED_SCRIPT = "/home/alma/Alma-Cli/Cleaner/Fix_Metadata/Src/Fix_Last_Modified/Fix_Last_Modified.py"

def parse_args():
    parser = argparse.ArgumentParser(description='Actualiza el campo responsable en metadatos YAML.')
    parser.add_argument('file', help='Ruta del archivo a modificar')
    parser.add_argument('--responsable', nargs='*', required=True, help='Nuevo(s) responsable(s)')
    parser.add_argument('--dry-run', action='store_true', help='Mostrar cambios sin guardar ni actualizar fecha/autor')
    parser.add_argument('--force', action='store_true', help='Forzar actualización aunque no haya cambios')
    return parser.parse_args()

def extract_yaml_block(content, ext):
    if ext in ['.yaml', '.yml']:
        return {'yaml_str': content, 'pre': '', 'post': '', 'triple_quotes': None}
    elif ext == '.md':
        lines = content.splitlines()
        if not lines or lines[0].strip() != '---':
            return None
        end_idx = None
        for i in range(1, len(lines)):
            if lines[i].strip() == '---':
                end_idx = i
                break
        if end_idx is None:
            return None
        pre = '\n'.join(lines[:1]) + '\n'
        yaml_str = '\n'.join(lines[1:end_idx])
        post = '\n' + '\n'.join(lines[end_idx:])
        return {'yaml_str': yaml_str, 'pre': pre, 'post': post, 'triple_quotes': None}
    elif ext == '.py':
        triple_quotes = None
        patterns = ['"""', "'''"]
        for pattern in patterns:
            start = content.find(pattern)
            if start != -1:
                triple_quotes = pattern
                break
        if triple_quotes is None:
            return None
        end = content.find(triple_quotes, start + len(triple_quotes))
        if end == -1:
            return None
        pre = content[:start]
        doc_content = content[start + len(triple_quotes):end]
        lines = doc_content.splitlines()
        if not lines or not lines[0].strip() == '---':
            return None
        yaml_str = '\n'.join(lines[1:])
        post = content[end + len(triple_quotes):]
        return {'yaml_str': yaml_str, 'pre': pre, 'post': post, 'triple_quotes': triple_quotes}
    return None

def update_responsable(yaml_data, responsables):
    # Si viene string, convertir a lista
    current = yaml_data.get('responsable', [])
    if isinstance(current, str):
        current = [current]
    if current != responsables:
        yaml_data['responsable'] = responsables
        return True
    return False

def process_file(args):
    file_path = args.file
    ext = os.path.splitext(file_path)[1].lower()

    if ext not in ['.md', '.yaml', '.yml', '.py']:
        logging.error("Extensión de archivo no soportada")
        print("Error: Extensión de archivo no soportada.")
        return False

    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
    except Exception as e:
        logging.error(f"Error leyendo archivo: {e}")
        print(f"Error leyendo archivo: {e}")
        return False

    yaml_info = extract_yaml_block(content, ext)
    if not yaml_info:
        logging.error("No se encontró encabezado YAML. Corré primero Validador_Metadata.py")
        print("No se encontró encabezado YAML. Corré primero Validador_Metadata.py")
        return False

    yaml_rt = YAML(typ='rt')
    yaml_rt.preserve_quotes = True

    try:
        yaml_data = yaml_rt.load(yaml_info['yaml_str']) or CommentedMap()
    except Exception as e:
        logging.error(f"Error parseando YAML: {e}")
        print(f"Error en formato YAML: {e}")
        return False

    has_changes = update_responsable(yaml_data, args.responsable) or args.force
    if not has_changes:
        print("Sin cambios: el responsable es el mismo.")
        return True

    stream = StringIO()
    yaml_rt.dump(yaml_data, stream)
    new_yaml_str = stream.getvalue()

    if ext in ['.yaml', '.yml']:
        new_content = new_yaml_str
    elif ext == '.md':
        new_content = yaml_info['pre'] + new_yaml_str + yaml_info['post']
    elif ext == '.py':
        new_doc = f"{yaml_info['triple_quotes']}---\n{new_yaml_str}{yaml_info['triple_quotes']}"
        new_content = yaml_info['pre'] + new_doc + yaml_info['post']

    if args.dry_run:
        print("Dry-run: Cambios propuestos:")
        print(new_content)
        return True

    try:
        with open(file_path, 'w', encoding='utf-8') as f:
            f.write(new_content)
        print("Campo responsable actualizado correctamente.")
    except Exception as e:
        logging.error(f"Error guardando archivo: {e}")
        print(f"Error guardando archivo: {e}")
        return False

    # Llamar a Fix_Last_Modified.py
    user = os.getenv('USER') or os.getenv('USERNAME') or 'alma'
    try:
        result = subprocess.run(
            ['python3', FIX_LAST_MODIFIED_SCRIPT, file_path, user],
            capture_output=True,
            text=True
        )
        if result.returncode != 0:
            print(f"✗ Error llamando a Fix_Last_Modified.py: {result.stderr.strip()}")
            logging.error(f"Fix_Last_Modified.py error: {result.stderr.strip()}")
            return False
        else:
            print("Fecha y autor de última modificación actualizados.")
    except Exception as e:
        print(f"✗ Error ejecutando Fix_Last_Modified.py: {str(e)}")
        logging.error(f"Error ejecutando Fix_Last_Modified.py: {str(e)}")
        return False

    return True

def main():
    args = parse_args()
    success = process_file(args)
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()
