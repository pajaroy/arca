

2025-05-29
üîÅ Se archiv√≥ metodolog√≠a antigua de estructuras aut√≥nomas como versi√≥n v0.1.
üìò Nueva versi√≥n mejorada registrada en: docs/metodologia_estructura_autonoma_v2.md

## üóìÔ∏è 2025-06-03 ‚Äì Incorporaci√≥n de nueva metodolog√≠a CLI-IA

### ‚úÖ Cambios realizados:
- Se cre√≥ el archivo metodol√≥gico: **metodolog√≠a para entornos CLI integrados con IA**.
- Se integr√≥ a la carpeta `/docs/metodologias/` con nombre fechado para trazabilidad.
- Se defini√≥ que todos los archivos de metodolog√≠a deben tener formato fechado.
- Se habilita uso de enlaces relativos para trazabilidad desde changelog y otros m√≥dulos.

`](./metodologias/2025-06-03_metodologia_estructura_cli_ia_v1.md)
### üîó Archivo relacionado:
[[docs/metodologias/2025-06-03_metodologia_estructura_cli_ia_v1|2025-06-03_metodologia_estructura_cli_ia_v1]]

### üè∑Ô∏è Tags:
#metodologia #cli #ia #estructura #trazabilidad #alma_resist


üîó Archivos clave:  
- `[[Kael]]`  
- `[[criterios_ubicacion_vivo.md]]`  
- `[[2025-06-03_apendice_nombres_modulos_ejecutables.md]]`  
- `[[tree_alma_resist.md]]` ‚Äì `[[tree_control_central.md]]` ‚Äì `[[tree_core.md]]`


module: introduccion/context
type: core
status: in_progress
created: '2025-05-23'
linked_to:
- metodologia_doc_ia_v2.md


## üßæ Contexto Hist√≥rico

El presente documento refleja la evoluci√≥n progresiva del sistema ALMA_RESIST.  
Se conserva el historial t√©cnico para trazabilidad de decisiones, cierres de sprint y evoluci√≥n modular.


## üóÇ Estructura Base

```
ALMA_RESIST/
‚îú‚îÄ‚îÄ core/                  ‚Üí M√≥dulos funcionales actuales
‚îú‚îÄ‚îÄ tests/                 ‚Üí Test unitarios por m√≥dulo
‚îú‚îÄ‚îÄ prompts/               ‚Üí Prompts t√©cnicos asociados
‚îú‚îÄ‚îÄ docs/                  ‚Üí Documentaci√≥n t√©cnica, hist√≥rica y estrat√©gica
‚îú‚îÄ‚îÄ logs/                  ‚Üí Registros estructurados (pueden estar cifrados)
‚îî‚îÄ‚îÄ scripts/               ‚Üí Scripts auxiliares (arranque, backups, automatizaciones)
```


## üß± M√≥dulos T√©cnicos Actuales

| M√≥dulo               | Ubicaci√≥n             | Estado  |
|----------------------|------------------------|---------|
| Logging estructurado | `core/log_writer.py`   | ‚úÖ |
| Cifrado de logs      | `core/log_crypto.py`   | ‚úÖ |
| ALMA_LOADER base     | `core/loader.py`       | üß™ (prototipo) |


## üß≠ Pr√≥ximos Pasos

üëâ Crear checklist para Sprint T√©cnico 0.0.0.3  
üëâ Definir objetivo t√©cnico: CLI inteligente, memoria modular, IA m√≠nima funcional  
üëâ Iniciar integraci√≥n de reflexi√≥n automatizada y feedback sem√°ntico de documentos

## üìé Ap√©ndice ‚Äì Estado operativo validado (2025-05-23)

El sistema ALMA_RESIST implementa un pipeline interno de validaci√≥n documental completamente funcional y validado, alineado con la metodolog√≠a modular declarada.

### üß† Capacidades integradas

- Validaci√≥n sint√°ctica y sem√°ntica de todos los archivos `.md` mediante `validate_docs.py`
- Correcci√≥n autom√°tica de metadatos YAML (`fix_metadata.py`)
- Normalizaci√≥n de rutas modulares (`force_snake_case_modules.py`)
- Ejecuci√≥n centralizada v√≠a script bash (`validar_documentacion.sh`)
- Backup autom√°tico de los cambios en carpetas versionadas
- Registro sistem√°tico en bit√°coras, changelogs y decisiones arquitect√≥nicas

### üìÅ Documentaci√≥n asociada

- `docs/utilidades/`
- `docs/decisiones_arquitectonicas.md`
- `docs/changelog.md`
- `docs/resgistros/bitacoras/bitacora_2025-05-23.md`
- `scripts/`

Este conjunto funcional sienta la base para una futura integraci√≥n CI/CD y garantiza trazabilidad completa sobre la estructura viva del sistema.


## üîÑ Ap√©ndice Sprint 2.5

Durante este sprint se consolid√≥ la estructura modular como arquitectura final del sistema. Se validaron nombres, carpetas, scripts, y puntos de entrada. El contexto general ahora puede ser interpretado tanto por humanos como por asistentes IA, facilitando b√∫squedas, automatizaciones y trazabilidad.

El contenido anterior de este archivo queda como referencia del proceso previo al redise√±o.


title: "Bit√°cora de Instalaci√≥n ALMA_RESIST"
date: 2025-06-01
tags: [#instalacion, #alma_resist, #configuracion_inicial, #bitacora, #alma_core, #alma_cli, #obsidian, #input_leap, #tmux, #rsync, #parrot_os]
module: alma_resist
type: bitacora
status: validado
linked_to: [control_central, alma_cli/auditor_textos, metodologias/estructura_autonoma]

## ‚úÖ 1. Instalaci√≥n de paquetes base

```bash
sudo apt update && sudo apt upgrade -y
sudo apt install -y git curl tmux vim htop net-tools openssh-server unzip rsync sqlite3 python3 python3-pip tree
```


## üîó 3. Configuraci√≥n de red y sincronizaci√≥n SSH

- **Nodos**:
  - ALMA_CORE ‚Üí `192.168.1.33`
  - ALMA_RESIST ‚Üí `192.168.1.36`

Verificar conectividad:

```bash
ssh bird@192.168.1.36
ssh bird@192.168.1.33
```

Generar y copiar claves SSH:

```bash
ssh-keygen -t ed25519 -C "bird@alma-resist"
ssh-copy-id bird@192.168.1.33
```


## üß± 5. Instalaci√≥n y uso b√°sico de Tmux

```bash
sudo apt install tmux -y
tmux new -s alma_core
tmux new -s alma_resist
```

Atajos:
- Ctrl+b ‚Üí % (dividir horizontal)
- Ctrl+b ‚Üí " (dividir vertical)
- Ctrl+b ‚Üí c (nueva ventana)
- Ctrl+b ‚Üí d (detach)


## üñºÔ∏è Fix √≠conos faltantes en Obsidian

```bash
sudo apt install -y fonts-noto fonts-noto-color-emoji fonts-material-design-icons-iconfont fonts-roboto fonts-font-awesome
fc-cache -fv
```


# üß© Proyecci√≥n IA-Friendly

Este archivo incluye:

- `tags` normalizados
- `linked_to` a m√≥dulos clave
- Bit√°cora en formato markdown y versionable
- Estructura compatible con CLI y agentes LLM futuros

Ideal para ser indexado por el m√≥dulo `auditor_textos` y alimentar motores de b√∫squeda interna sem√°ntica en el ecosistema ALMA.


# [FIN DEL DOCUMENTO]




module: metodologias/archivadas/metodologia_adr_v1
type: core
status: in_progress
created: '2025-05-21'
linked_to:
- metodologia_doc_ia_v2.md


## ‚úÖ ¬øQu√© es un ADR?

Un **Architecture Decision Record (ADR)** es un documento que responde:  
> ‚Äú¬øPor qu√© tomamos esta decisi√≥n t√©cnica en este punto del tiempo?‚Äù

Su objetivo es dejar constancia de **decisiones estructurales, tecnol√≥gicas o estrat√©gicas** que pueden afectar la evoluci√≥n futura del sistema.


## üìÅ Ubicaci√≥n oficial

Todos los ADR deben guardarse en:  
```
docs/adr/
```

Nombrados de forma incremental y descriptiva:

```
docs/adr/001-estructura-modular.md
docs/adr/002-versionado-semver.md
docs/adr/003-ia-local-mistral.md
```


## üìò Ejemplo real

```markdown
# ADR 002 ‚Äì Adopci√≥n de versionado SemVer

üìÖ Fecha: 2025-05-18  
üéØ Estado: Adoptado

## Decisi√≥n
Utilizar `MAJOR.MINOR.PATCH` como convenci√≥n de versionado global.

## Contexto
Se necesitaba un est√°ndar para versionar snapshots y scripts sin ambig√ºedad.

## Alternativas consideradas
- Fechas (`2025-05-18`)
- Commit hashes
- Versionado manual ad-hoc

## Justificaci√≥n
SemVer es ampliamente utilizado, f√°cil de entender y permite automatizaci√≥n futura.

## Impacto
Afecta a changelog.md, backups, carpetas `/versiones/`, y documentaci√≥n general.

## Relacionado con
- metodologia_versionado_backups_v1.md
- Sprint_2.2
```

## Archivo: metodologia_doc_ia_v1.md
Contenido:
# üìò Metodolog√≠a de Documentaci√≥n para Humanos + IA ‚Äì ALMA_RESIST (v1)

üìÖ Versi√≥n: 1.0  
üìÅ Archivo: metodologia_doc_ia_v1.md  
üéØ Objetivo: Establecer un est√°ndar de documentaci√≥n que sea simult√°neamente legible para humanos, y navegable, indexable y procesable por sistemas de IA como Alma.


## üß† Fundamento

La IA funciona mejor cuando la documentaci√≥n:

- Tiene **estructura expl√≠cita**
- Usa **tags consistentes**
- Declara **relaciones entre m√≥dulos**
- Se puede leer como una base de datos viva

Por eso se define el uso obligatorio del bloque `frontmatter` YAML.

module: "core/cli"
type: "core"          # core | external | tool | integration | draft
domain: "infraestructura"   # general | cultivo | historia | ia | trading
tags: ["CLI", "modularidad", "entrada"]
status: "stable"      # in_progress | stable | deprecated
linked_to: ["memoria", "resumen"]
created: "2025-05-21"
version: "0.2"

## üè∑Ô∏è Campos requeridos

| Campo       | Descripci√≥n t√©cnica                                                        |
|-------------|-----------------------------------------------------------------------------|
| `module`    | Identificador √∫nico del m√≥dulo o documento                                  |
| `type`      | Tipo de documento: n√∫cleo, externo, herramienta, integraci√≥n, etc.          |
| `domain`    | Dominio funcional principal (ej: cultivo, historia, IA, trading)            |
| `tags`      | Lista de palabras clave normalizadas                                        |
| `linked_to` | Otros m√≥dulos relacionados                                                  |
| `status`    | Estado del documento                                                        |
| `version`   | Versi√≥n local del documento o m√≥dulo                                        |
| `created`   | Fecha de creaci√≥n                                                           |


## üìò Ejemplo completo

```markdown

# Loader ‚Äì N√∫cleo de Carga de Modelo LLM

Este m√≥dulo se encarga de inicializar, cargar y coordinar el modelo IA local utilizado por Alma...
```


## üîÑ Relaci√≥n con otras metodolog√≠as

- Requiere implementaci√≥n dentro de: `estructura_modular_v2`
- Afecta directamente a: `sprints_v2`, `auditor√≠a_adr`, `interacci√≥n_ia`
- Ser√° utilizada en: `alma-cli`, `alma-loader`, `grafos_ia`

## Archivo: metodologia_estructura_autonoma_v1.md
Contenido:
# Metodolog√≠a de Trabajo en Carpetas Aut√≥nomas

Esta metodolog√≠a define la estructura m√≠nima y escalable para trabajar de manera aut√≥noma dentro de una carpeta, √∫til para proyectos personales, m√≥dulos tem√°ticos o pruebas aisladas dentro del entorno ALMA_RESIST.

## üìÅ Estructura base sugerida

```bash
nombre_modulo/
‚îú‚îÄ‚îÄ docs/                    # Documentaci√≥n del m√≥dulo (readme, changelog, bit√°coras)
‚îÇ   ‚îú‚îÄ‚îÄ readme.md            # Descripci√≥n del m√≥dulo
‚îÇ   ‚îú‚îÄ‚îÄ version.md           # Versi√≥n actual del m√≥dulo
‚îÇ   ‚îî‚îÄ‚îÄ bitacoras/           # Notas de trabajo fechadas
‚îú‚îÄ‚îÄ datasets/                # Datos crudos o procesados (CSV, JSON, etc.)
‚îú‚îÄ‚îÄ scripts/                 # Scripts Python o Bash de procesamiento o validaci√≥n
‚îú‚îÄ‚îÄ notebooks/               # Notebooks de an√°lisis o pruebas exploratorias
‚îú‚îÄ‚îÄ downloads/               # Archivos externos temporales (nunca en git)
‚îú‚îÄ‚îÄ tests/                   # Pruebas unitarias o de integraci√≥n
‚îú‚îÄ‚îÄ logs/                    # Logs de ejecuci√≥n, errores o auditor√≠as
‚îî‚îÄ‚îÄ config/                  # Configuraciones, variables de entorno, APIs
```

## ‚úÖ Buenas pr√°cticas

- Usar `snake_case` para carpetas y archivos.
- Los documentos `.md` deben incluir un encabezado YAML con metadatos.
- Los archivos en `downloads/` y `logs/` deben estar excluidos de versionado (`.gitignore`).
- Mantener cada carpeta lo m√°s at√≥mica y autocontenida posible.
- Idealmente cada script tiene su `README.md` asociado en `scripts/`.

## üß© Ventajas

- Modularidad completa y portabilidad.
- F√°cil integraci√≥n con ALMA_RESIST copiando la carpeta dentro de `docs/modules/`.
- Adaptabilidad para proyectos personales de salud, trading, cannabis, IA, etc.

## üìå Uso recomendado

1. **Inicializar estructura**
   ```bash
   mkdir -p nombre_modulo/{docs/bitacoras,datasets,scripts,notebooks,downloads,tests,logs,config}
   ```

2. **Crear archivos iniciales**
   ```bash
   touch nombre_modulo/docs/{readme.md,version.md}
   ```

3. **Completar metadatos y empezar documentaci√≥n.**

4. **Mantener una bit√°cora de avances en `docs/bitacoras/`.**

## Archivo: metodologia_estructura_modular_v1.md
Contenido:
# üß± Metodolog√≠a de Estructura Modular y Carpetas

üìÖ Versi√≥n: 1.0  
üéØ Objetivo: Establecer un est√°ndar profesional y escalable para construir cualquier carpeta, m√≥dulo o dominio que desee ser parte del sistema ALMA_RESIST.


## üì¶ Estructura M√≠nima por M√≥dulo

```
[m√≥dulo]/
‚îú‚îÄ‚îÄ README.md               # Descripci√≥n general y prop√≥sito
‚îú‚îÄ‚îÄ bitacora.md             # Registro libre de avances, reflexiones, decisiones
‚îú‚îÄ‚îÄ changelog.md            # Cambios por versi√≥n
‚îú‚îÄ‚îÄ estructura/             # Diagramas, esquemas, arquitectura visual (opcional)
‚îú‚îÄ‚îÄ docs/                   # Documentaci√≥n t√©cnica y contextual
‚îÇ   ‚îî‚îÄ‚îÄ metodologia_local.md   # C√≥mo funciona este m√≥dulo internamente
‚îú‚îÄ‚îÄ scripts/                # Automatizaciones o utilidades espec√≠ficas
‚îú‚îÄ‚îÄ data/                   # Archivos relevantes de entrada/salida
‚îú‚îÄ‚îÄ versionado/            # Copias congeladas (snapshots o entregas)
‚îÇ   ‚îî‚îÄ‚îÄ v0.0.0.1/...
```


## üìò Convenciones

- Nombres de carpetas y archivos en `snake_case`, sin espacios ni tildes.
- `scripts/` debe contener nombres funcionales: `gen_`, `load_`, `test_`.
- Markdown en estilo sem√°ntico (con secciones y sintaxis IA-legible).

module: "nombre_modulo"
type: "internal" | "external_domain" | "technical"
version: "0.1"
status: "in_progress"
tags: ["dominio", "tecnico", "legal"]
linked_to: ["ALMA_CORE", "cultivo", "loader"]

## üîÅ Relaci√≥n con otros protocolos

Esta metodolog√≠a es invocada desde:

- `Sprint_2.2_Metodologias_Base.md`
- `docs/01_methodologies/Methodology_Index.md`
- Cualquier auditor√≠a futura o proceso de integraci√≥n

## Archivo: metodologia_interaccion_ia_v1.md
Contenido:
# ü§ñ Metodolog√≠a de Interacci√≥n con IA ‚Äì ALMA_RESIST (v1)

üìÖ Versi√≥n: 1.0  
üìÅ Archivo: metodologia_interaccion_ia_v1.md  
üéØ Objetivo: Establecer c√≥mo los sistemas de IA (como Alma) deben interactuar con la documentaci√≥n, estructura y decisiones del sistema ALMA_RESIST de forma segura, trazable y eficiente.


## üß≠ Principios Rectores

1. **Lectura Sem√°ntica, No Libre**  
   La IA debe operar sobre documentos que contengan frontmatter YAML v√°lido.

2. **Contexto expl√≠cito**  
   La IA debe navegar a trav√©s de campos como `linked_to`, `tags`, `type` para entender relaciones.

3. **No modificar sin validaci√≥n**  
   Toda acci√≥n de escritura debe estar aprobada por el operador humano o IA validadora.

4. **Indexaci√≥n progresiva**  
   Los documentos se indexan como nodos con atributos (tipo, dominio, versi√≥n).

module: "core/cli"
type: "core"
domain: "infraestructura"
status: "stable"
tags: ["entrada", "modularidad"]
linked_to: ["resumen", "loader"]
created: "2025-05-21"
version: "0.2"

## üß† Modos de Interacci√≥n

| Modo         | Descripci√≥n                                                      |
|--------------|------------------------------------------------------------------|
| `lector`     | Solo lectura de archivos con YAML v√°lido                         |
| `asistente`  | Sugiere cambios, genera texto, resume, enlaza documentos         |
| `auditor`    | Verifica cumplimiento de est√°ndares y relaciones sem√°nticas      |
| `operador`   | Puede ejecutar acciones, generar ADRs, changelogs, etc. (futuro) |


## üîÑ Relaci√≥n con otras metodolog√≠as

- `metodologia_doc_ia_v2.md`: Define estructura m√≠nima para ser legible por IA
- `metodologia_adr_v2.md`: Relaciona decisiones estructurales con m√≥dulos IA-indexables
- `estructura_modular_v2`: Define d√≥nde debe ir cada documento


## üßæ Changelog

### 2025-05-21
- [v1.0] Creaci√≥n de protocolo base para interacci√≥n IA sem√°ntica
- Definici√≥n de 4 modos de operaci√≥n
- Reglas de validaci√≥n y acciones permitidas


module: metodologias/archivadas/metodologia_sprints_v1
type: core
status: in_progress
created: '2025-05-21'
linked_to:
- metodologia_doc_ia_v2.md


## ‚úÖ Aplicaci√≥n

Esta metodolog√≠a se aplica a:

- Mejoras internas o arquitect√≥nicas
- Nuevos m√≥dulos o dominios
- Auditor√≠as, migraciones, expansiones
- Cualquier proceso con entregables concretos


## üìã Estados posibles

| Estado     | Significado t√©cnico                                                      |
|------------|--------------------------------------------------------------------------|
| Activo     | En ejecuci√≥n                                                             |
| Cerrado    | Finalizado y documentado (impact√≥ changelog, hitos, versi√≥n)             |
| Archivado  | Conservado para trazabilidad pero ya sin funci√≥n activa                 |


## üß† Metadatos YAML en cada archivo de sprint

```yaml
```


## üéØ Objetivo
Texto conciso del prop√≥sito del sprint


## üìé Archivos relacionados
- [ ] core/cli.py
- [ ] changelog.md


## üîÅ Registro Final
- [x] Actualizado changelog.md
- [x] Agregado en hitos.md
- [x] Anotado en lecciones_aprendidas.md
```

## Archivo: _propuesta_v3_doc_ia.md
Contenido:
# üî≠ Propuesta de Implementaci√≥n Modular ‚Äì Documentaci√≥n Humano + IA (v2)

üìÖ Fecha: 2025-05-21  
üìÅ Asociado a: `Sprint_2.2_Metodologias_Base`  
üéØ Prop√≥sito: Integrar progresivamente una estructura documental sem√°ntica IA-friendly que sea viable para un √∫nico operador, con capacidad de escalar a automatizaci√≥n parcial.


## üìã Cambios Introducidos en `metodologia_doc_ia_v2.md`

| Mejora                      | Descripci√≥n t√©cnica clave                                                    |
|----------------------------|-------------------------------------------------------------------------------|
| üîπ Reducci√≥n de campos      | De 8 a 4 campos obligatorios (`module`, `type`, `status`, `created`)         |
| üîπ Campos opcionales        | `domain`, `tags`, `linked_to`, `version` quedan como sugeridos               |
| üîπ Pol√≠tica de migraci√≥n    | Etapas 1‚Äì2‚Äì3 para evitar sobrecarga en documentos existentes                  |
| üîπ Glosario t√©cnico         | Referencias r√°pidas para `type`, `domain`, `status`                          |
| üîπ Comando `alma-cli`       | Especificaci√≥n base para autocompletar bloques YAML v√≠a CLI con IA           |


## üß† Beneficios esperados

- Trazabilidad sem√°ntica sin burocracia
- IA como asistente documental real
- Minimizaci√≥n de deuda t√©cnica
- Posibilidad de detecci√≥n de m√≥dulos hu√©rfanos, duplicados o sin versionar


## üîÑ Estado actual

‚úÖ Ya se gener√≥ y archiv√≥ la metodolog√≠a v2  
üîú Pendiente implementaci√≥n de `alma-cli doc-init`  
üß© Listo para ser referenciado en pr√≥ximas decisiones ADR



module: metodologias/propuestas/propuesta_v3_estructura_modular
type: core
status: in_progress
created: '2025-05-21'
linked_to:
- metodologia_doc_ia_v2.md


## ‚úÖ Objetivo

Capturar propuestas de mejora avanzada para evolucionar la metodolog√≠a de estructura modular hacia una versi√≥n 3 m√°s automatizada, escalable y colaborativa, sin aplicarlas inmediatamente.


### 2. Documentaci√≥n Auto-Generada

- [ ] Incluir plantilla `mkdocs.yml`
- [ ] Agregar gu√≠a para despliegue en GitHub Pages
- [ ] Navegaci√≥n autom√°tica basada en `linked_to`, `tags`


### 4. Namespaces Jer√°rquicos

- [ ] Convenci√≥n para dominios complejos:
    - `trading/backtesting/`
    - `external/cannabird/`
```yaml
module: "trading:backtesting"
type: "core"
```


### 6. Repositorio de Plantillas (ALMA_TEMPLATES)

- [ ] Crear m√≥dulo `alma-templates/` o CLI tipo:
```bash
alma-cli new-module --type technical --name llm_processor
```


### 8. Compatibilidad Multientorno

- [ ] Estandarizar `config/`:
```bash
config/
‚îú‚îÄ‚îÄ dev/
‚îú‚îÄ‚îÄ staging/
‚îî‚îÄ‚îÄ prod/
```

```yaml
env_support: ["dev", "staging"]
```


### 10. Preparaci√≥n para Colaboradores Futuros

- [ ] Crear `CONTRIBUTING.md` con:
    - Flujo de PR
    - Validaci√≥n de metadatos
    - Gu√≠a para `dev_journal.md`




module: metodologias/propuestas/propuesta_v3_interaccion_ia
type: core
status: in_progress
created: '2025-05-22'
linked_to:
- metodologia_doc_ia_v2.md


## üîÆ Visi√≥n futura

- Integraci√≥n en tiempo real con m√∫ltiples agentes (CLI + Chat + Webhook)
- Inferencia autom√°tica de `linked_to` por NLP contextual
- Reconocimiento sem√°ntico y clustering por dominio (`trading`, `cultivo`, etc.)
- Actualizaci√≥n autom√°tica de `status`, `version`, `impact` por commits


## üõ†Ô∏è CLI y Automatizaci√≥n

```bash
alma-cli review-missing-context
alma-cli auto-link --domain cultivo
alma-cli summarize-changes --since v2.1
```


## üå± Implementaci√≥n sugerida

Fase 1: IA como auditor+asistente en todos los sprints  
Fase 2: Comandos CLI activos para sugerencia y migraci√≥n  
Fase 3: Agente aut√≥nomo con control limitado (operador validando)

### 2. **Ejemplos de Flujos de Trabajo Aut√≥nomos**

```markdown
# docs/ia_workflows/autolink_example.md  
1. IA detecta que `cultivo/riego.md` menciona "fertilizaci√≥n" 3 veces  
2. Sugiere a√±adir tag `fertilizaci√≥n` y link a `cultivo/fertilizantes.md`  
3. Si el operador aprueba, actualiza YAML autom√°ticamente  
```


### 4. **Transici√≥n Gradual de Fases**

```mermaid
graph TD  
  A[Fase 1: Auditor+Asistente] -->|+10 m√≥dulos| B[Fase 2: CLI Activo]  
  B -->|+20 m√≥dulos| C[Fase 3: Agente Aut√≥nomo]  
  C -->|Backup diario| D[Failsafe: Rollback autom√°tico]  
```

**Checklist de habilitaci√≥n**:
- Tests de integraci√≥n IA al 95%
- Documentaci√≥n de rollback en `docs/emergency.md`


### 6. **Monitorizaci√≥n de Recursos**

```bash
alma-cli monitor --cpu --memory --graph-complexity
```

**M√©tricas clave**:
- Tiempo de respuesta IA por m√≥dulo
- RAM consumida en inferencias complejas
- Nodos hu√©rfanos en grafo sem√°ntico

## Archivo: prompt_technical_ALMA_LOADER_v3.0.2.md
Contenido:
# üß† Prompt T√©cnico ALMA_LOADER v3.0

## üß≠ Roadmap T√©cnico ALMA_LOADER ‚Äì Versi√≥n Expandida


### üî∑ B. Roadmap Operativo Detallado (vinculado al desarrollo actual)

> Esta secci√≥n detalla las tareas concretas, m√≥dulos activos y enlaces con los cuadernos digitales. Se actualiza por versi√≥n (actual: 3.0.3+).

#### üéØ Objetivo General

Consolidar un backend modular, seguro y ampliable que act√∫e como n√∫cleo inteligente de un asistente personal diario. Toda la l√≥gica y estructura se mantiene sintetizada en dos archivos base (`whitepaper` y `prompt t√©cnico`) para m√°xima claridad e interoperabilidad con modelos de lenguaje. Se prioriza compatibilidad con cuadernos digitales (Obsidian, Shortcuts, Recordatorios).


#### üß† Fase 2 ‚Äì IA B√°sica y Consultas
- Endpoint `/v1/assistant/consultar`
- Uso de modelo externo para responder con contexto
- Creaci√≥n de `core/racionalizador.py`
- Prompts funcionales en el prompt t√©cnico
- Nueva secci√≥n: ‚ÄúCapas de interacci√≥n con IA‚Äù


#### üîê Fase 4 ‚Äì Seguridad y Despliegue
- JWT real y m√∫ltiples usuarios
- Dockerfile + `docker-compose`
- Endpoint de monitoreo b√°sico
- Telegram + Shortcuts como interfaz liviana


#### üìò Notas Finales
- Toda evoluci√≥n queda registrada en el `CHANGELOG.md`
- Se prioriza siempre claridad conceptual antes que escalamiento t√©cnico
## 1. Prop√≥sito del Sistema
Este prompt define todas las funciones t√©cnicas, estructuras internas y flujos de interacci√≥n del sistema ALMA_LOADER. Su objetivo es que cualquier modelo IA o humano t√©cnico pueda ejecutar, extender o auditar el sistema con claridad total. Consolidado a partir de versiones 2.1.1 y 2.2.0.
El Prompt T√©cnico: **‚Äúenfoque t√©cnico y operacional‚Äù**
Para la perspectiva emocional y filos√≥fica del sistema, ver el Pr√≥logo del Whitepaper.‚Äù
> üìò Para entender el prop√≥sito humano, los casos de uso y la visi√≥n general del sistema,  
> consult√° el [Whitepaper de ALMA_LOADER](ALMA_LIBRE/MODULOS/Alma_Loader/alma_loader_v3.0.3/docs/archivos_fundamentales/whitepaper_ALMA_LOADER_v3.0.2.md)

## 2. M√≥dulos Funcionales
- `core_nl.py` ‚Äì Conversi√≥n NL ‚Üí JSON mediante reglas y patrones
- `validador.py` ‚Äì Validaci√≥n con `schema_base.json` y normalizaci√≥n de campos
- `sqlite_storage.py` ‚Äì Almacenamiento actual, optimizado con JSON1 para consultas internas
- `base_storage.py` ‚Äì Interfaz abstracta de almacenamiento compatible con m√∫ltiples motores
- `vector_storage.py` ‚Äì B√∫squeda sem√°ntica con embeddings v√≠a FAISS (alpha)
- `router_atencional.py` ‚Äì Enrutamiento seg√∫n intenci√≥n detectada (acci√≥n, reflexi√≥n, memoria)
- `resumenes.py` ‚Äì Generaci√≥n de resumen en Markdown diario o semanal
- `alma_analytics.py` ‚Äì Detecci√≥n de patrones, correlaciones y disparadores
- `gamificacion.py` ‚Äì Sistema de motivaci√≥n por puntos, niveles y h√°bitos (fase 3)

Los m√≥dulos de ALMA_LOADER est√°n dise√±ados para ser independientes y f√°cilmente intercambiables. A continuaci√≥n, se indican las principales tecnolog√≠as asociadas a cada uno:

### üõ†Ô∏è Tecnolog√≠as Utilizadas por M√≥dulo

| M√≥dulo                   | Tecnolog√≠a / Herramienta              |
|--------------------------|--------------------------------------|
| NLP / Parsing            | `regex`, `spaCy` (plan futuro)       |
| Vectorizaci√≥n sem√°ntica | `sentence-transformers`, `FAISS`     |
| Almacenamiento           | `SQLite` (con JSON1), `FAISS` (alpha)|
| Visualizaci√≥n / Testing  | `pytest`, `Mermaid` (para diagramas) |
| Relaciones sem√°nticas    | `dict`, relaciones cruzadas (`Neo4j`, `networkx` ‚Äì futuro) |


## 3. JSON Schema de Memoria
```json
{
  "id": "MEM-TRD-2025-XXXX",
  "categoria": "TRD",
  "contenido": "texto plano",
  "tags": ["#btc", "#reflexi√≥n"],
  "resumen_inferido": "...",
  "embedding_id": "EMB-abc123",
  "vector": [0.123, 0.987, ...],
  "intencion_detectada": "registro",
  "origen_input": "usuario",
  "relaciones": [
    { "tipo": "temporal", "target_id": "MEM-TRD-2025-XXXX", "peso": 0.8 }
  ]
}
```

> Este prompt t√©cnico permite que cualquier IA ejecute acciones correctas dentro de ALMA_LOADER sin ambig√ºedades ni errores de interpretaci√≥n. Complementa al whitepaper 3.0 (explicativo y estrat√©gico).

## 9. Testing y Validaciones

### üß™ Test Unitario ‚Äì Validaci√≥n de Memoria

Este test permite verificar que el esquema base JSON acepte estructuras v√°lidas y rechace incorrectas. Se usa como prueba m√≠nima para `validador.py`.

```python
def test_validar_memoria():
    memoria_valida = {
        "id": "MEM-TRD-2025-05-06-001",
        "categoria": "TRD",
        "contenido": "Hoy oper√© en BTC y me sent√≠ confiado",
        "tags": ["#btc", "#emoci√≥n:confianza"]
    }
    assert validar_esquema(memoria_valida) == True
```

Este tipo de test puede ejecutarse con `pytest`, `unittest`, o integrarse en un pipeline de verificaci√≥n previa al guardado.

### üß™ Test Unitario ‚Äì Vectorizaci√≥n Sem√°ntica

Este test valida que la funci√≥n de embeddings est√© operativa y produzca un vector v√°lido (usualmente de 384 o 768 dimensiones, seg√∫n modelo).

```python
def test_vectorizacion():
    texto = "Hoy oper√© bajo presi√≥n y me sent√≠ impulsivo."
    vector = generar_embedding(texto)
    
    assert isinstance(vector, list)
    assert len(vector) >= 128
    assert all(isinstance(x, float) for x in vector)
```

> Este test puede servir tanto para debug local como para verificar integridad del motor FAISS en producci√≥n.

## 10. Relaciones entre Memorias ‚Äì Grafo Dirigido

ALMA_LOADER permite establecer v√≠nculos expl√≠citos entre memorias usando el campo `relaciones`. Esto habilita un grafo dirigido de conocimiento interno.

Cada relaci√≥n incluye:
- `tipo`: naturaleza de la relaci√≥n (ej: `temporal`, `causal`, `emocional`, `refuerzo`)
- `target_id`: ID de la memoria relacionada
- `peso`: valor entre 0 y 1 que indica la fuerza del v√≠nculo

### üìÑ Ejemplo:
```json
"relaciones": [
  { "tipo": "causal", "target_id": "MEM-TRD-2025-05-04-002", "peso": 0.85 },
  { "tipo": "temporal", "target_id": "MEM-TRD-2025-05-03-001", "peso": 0.6 }
]
```

Este grafo puede analizarse para:
- Descubrir patrones encadenados (causas ‚Üí consecuencias)
- Medir recurrencia o acumulaci√≥n emocional
- Visualizar el recorrido mental de un tema

### üõ†Ô∏è Futuras integraciones:
- `networkx` (Python) para an√°lisis de grafos
- `Neo4j` para persistencia de relaciones complejas
- Mermaid o D3.js para visualizaci√≥n gr√°fica

> El objetivo es pasar de registros aislados a una red din√°mica de aprendizaje personal.

## üîå Integraci√≥n con M√≥dulos Externos

ALMA_LOADER est√° dise√±ado para operar como n√∫cleo de memoria e inteligencia sem√°ntica para m√∫ltiples aplicaciones.

Esta versi√≥n 3.0.2 introduce una estructura preparada para la futura integraci√≥n de m√≥dulos externos. Cada uno de estos m√≥dulos podr√° interactuar con el sistema a trav√©s de sus interfaces y funciones expuestas.

### Ejemplos de m√≥dulos potenciales (en evaluaci√≥n):
- üìä Analizador de Trading Emocional
- üå± Gestor Inteligente de Cultivo
- üìî Bit√°cora Personal Automatizada
- üß† Asistente de Decisiones Estrat√©gicas
- üí∞ Controlador de Fondos y Riesgo

> En futuras versiones, cada m√≥dulo tendr√° su documentaci√≥n (`README`) y prompt local, conectado a ALMA_LOADER como backend de memoria.

Esta secci√≥n ser√° actualizada a medida que se confirmen las integraciones.

### 4.1 üåê API REST (Dise√±o Futuro)

ALMA_LOADER est√° preparado para exponer una API REST que permita la integraci√≥n con interfaces externas, aplicaciones m√≥viles, dashboards anal√≠ticos, asistentes de voz y automatizaciones.

La API ser√° desarrollada con FastAPI y seguir√° est√°ndares modernos (OpenAPI 3.1).

### üîå Endpoints planeados (versi√≥n inicial)

| M√©todo | Endpoint             | Descripci√≥n breve                              |
|--------|----------------------|-------------------------------------------------|
| POST   | /memorias            | Registra una nueva memoria                     |
| GET    | /memorias            | Devuelve todas las memorias                    |
| GET    | /memorias/{id}       | Busca una memoria por ID                       |
| GET    | /memorias/search     | B√∫squeda sem√°ntica por contenido o tags        |
| POST   | /memorias/relacionar | Enlaza dos memorias existentes                 |
| GET    | /tags                | Lista todos los tags usados                    |
| GET    | /memorias/recientes  | Devuelve √∫ltimas N memorias registradas        |

### üß© Ejemplo de integraci√≥n futura

```http
POST /memorias
Content-Type: application/json

{
  "id": "MEM-TRD-2025-05-06-001",
  "categoria": "TRD",
  "contenido": "Oper√© ETH/USD con 3% de riesgo tras dormir poco.",
  "tags": ["#fatiga", "#riesgo", "#trading"]
}
```

Este input ser√° validado con `schema_base.json`, almacenado v√≠a `SQLiteStorage`, vectorizado (FAISS) y procesado por `on_memoria_guardada()` si aplica.

> Esta API ser√° lanzada como parte de la versi√≥n 3.1.x de ALMA_LOADER.
## 5. Diagramas del Sistema
```mermaid
flowchart TD
    input["üßë Usuario o IA"] --> nl["core_nl.py"]
    nl --> validador["validador.py"]
    validador --> router["router_atencional.py"]
    router --> storage["sqlite_storage / vector_storage"]
    router --> resumenes["resumenes.py"]
    resumenes --> output["üìÑ Markdown / Dashboard"]
    storage --> analytics["alma_analytics.py"]
    analytics --> output
```

## 6. Escalabilidad y Visi√≥n Futura
- Vectorizaci√≥n total y enlaces entre memorias (grafos)
- Reemplazo de SQLite por motores orientados a relaciones (Neo4j)
- Integraci√≥n con asistentes personales v√≠a voz, API y web
- Memorias multiusuario con capas de privacidad

## 7. Recomendaciones de Integraci√≥n
- El sistema espera entradas en lenguaje natural o JSON v√°lido
- Cada m√≥dulo puede operar por separado (desacoplamiento limpio)
- Ideal para integrarlo como backend de un asistente IA
- DeepSeek, GPT o interfaces custom pueden usarlo como n√∫cleo de memoria conversacional
## 8. Comandos √ötiles ‚Äì Modo Asistente

ALMA_LOADER puede ser utilizado como un asistente conversacional desde cualquier interfaz (terminal, Telegram, Shortcuts, GPT, etc.). A continuaci√≥n, algunos ejemplos de uso:

### üìò Comandos de Registro
- `/nueva Hoy gan√© $100 operando BTC con alta ansiedad`
- `/nueva Me sent√≠ estancado y sin claridad esta semana`

### üìô Comandos de Acci√≥n
- `/accion Meditar 15 minutos despu√©s del mercado`
- `/accion Ajustar riesgo a 1% esta semana`

### üìó Comandos de Reflexi√≥n
- `/reflexion Me doy cuenta que opero peor cuando duermo poco`
- `/reflexion Revisar trades similares a MEM-TRD-2025-04-10`

### üìï Comandos de Consulta
- `/resumen semana`
- `/alertas activas`
- `/recomendar memoria relacionada con ansiedad y sobreoperaci√≥n`

> Cada uno de estos comandos ser√° procesado y transformado en memoria, acci√≥n o reflexi√≥n seg√∫n el m√≥dulo de atenci√≥n.


## üß≠ Roadmap General Estrat√©gico ‚Äì ALMA_LOADER Post v3.0.3

### üéØ Objetivo General

Consolidar un backend modular, seguro y ampliable que act√∫e como n√∫cleo inteligente de un asistente personal diario. Toda la l√≥gica y estructura se mantiene sintetizada en dos archivos base (`whitepaper` y `prompt t√©cnico`) para m√°xima claridad e interoperabilidad con modelos de lenguaje. Se prioriza compatibilidad con cuadernos digitales (Obsidian, Shortcuts, Recordatorios).


### üß† Fase 2 ‚Äì IA B√°sica y Consultas
- Endpoint `/v1/assistant/consultar`
- Uso de modelo externo para responder con contexto
- Creaci√≥n de `core/racionalizador.py`
- Prompts funcionales en el prompt t√©cnico
- Nueva secci√≥n: ‚ÄúCapas de interacci√≥n con IA‚Äù


### üîê Fase 4 ‚Äì Seguridad y Despliegue
- JWT real y m√∫ltiples usuarios
- Dockerfile + `docker-compose`
- Endpoint de monitoreo b√°sico
- Telegram + Shortcuts como interfaz liviana


### üß© Notas Finales
- Toda evoluci√≥n queda registrada en el `CHANGELOG.md`
- Se prioriza siempre claridad conceptual antes que escalamiento t√©cnico

## üßæ Anexo Hist√≥rico ‚Äì Evoluci√≥n del Sistema

> Registro consolidado de avances funcionales y t√©cnicos por versi√≥n (v3.0.0 ‚Üí v3.0.2).


#### üöÄ Versi√≥n 3.0.1 ‚Äì Profesionalizaci√≥n T√©cnica

### ‚úÖ Objetivos:
- Incluir elementos t√©cnicos reales que permitan operar y testear el sistema.
- Preparar el motor para trabajar con FAISS, SQLite y validaciones avanzadas.

### üõ†Ô∏è Implementaciones:
- Ejemplo real de test unitario para validaci√≥n de memorias.
- Agregado de tabla de tecnolog√≠as usadas (spaCy, sentence-transformers, FAISS, SQLite).
- Caso real de regla din√°mica en `reglas_dinamicas.json`.
- Documentaci√≥n de la coexistencia entre SQLite y FAISS (con `embedding_id`).
- Refuerzo de consistencia entre m√≥dulos en prompt y whitepaper.


### üîö Resultado

> ALMA_LOADER hoy es un sistema **modular, documentado, integrable y escalable** que puede:
- Operar como backend sem√°ntico de cualquier app (cultivo, trading, bit√°coras).
- Ser entendido por humanos o IAs con solo 2 archivos centrales.
- Adaptarse a futuras versiones de forma incremental y trazable.

module: mvp/resumen_mvp
type: core
status: in_progress
created: '2025-05-22'
linked_to:
- metodologia_doc_ia_v2.md


## üß† ¬øQu√© es ALMA_RESIST?

ALMA_RESIST es un entorno operativo portable, antifr√°gil y orientado a terminal, dise√±ado para ser la base t√©cnica de un sistema de IA distribuido, resiliente y aut√≥nomo. Su prop√≥sito es servir como n√∫cleo funcional de trabajo local con IA, memoria extendida y sincronizaci√≥n con entornos espejo.


## ‚öôÔ∏è Componentes Implementados

| Componente               | Estado   | Observaciones                                       |
|--------------------------|----------|-----------------------------------------------------|
| `log_writer.py`          | ‚úÖ        | Log funcional, con metadatos completos              |
| `log_crypto.py`          | ‚úÖ        | Log cifrado AES/ChaCha funcional                    |
| `hitos.md`               | ‚úÖ        | Estructura con versi√≥n 0.0.0.1                      |
| `changelog.md`           | ‚úÖ        | Control de cambios detallado                        |
| `auditoria_estructura.md`| ‚úÖ        | Evaluaci√≥n cr√≠tica de la estructura del sistema     |
| `resumen_secciones.md`   | ‚úÖ        | Estado actual por m√≥dulo                            |
| `docs/versiones/README.md`| ‚úÖ       | Estandarizaci√≥n de versiones congeladas             |


## üöß Consideraciones

El MVP no busca ser utilizable por terceros a√∫n. Su prop√≥sito es **sentar las bases t√©cnicas**, validar estructura y establecer est√°ndares. Todo lo construido est√° orientado a escalarse, no a entregarse.


## üîó Relacionado

- [[13cc/registros/hitos]]
- [[13cc/dev/changelog]]
- [[ALMA_RESIST/logs/auditorias/auditoria_estructura]]
- [[ALMA_RESIST/docs/resumen_secciones]]
  

## üß† Qu√© incluye esta versi√≥n

Sprint de consolidaci√≥n metodol√≥gica:
- Implementaci√≥n de CLI funcional (core/cli.py)
- Modularizaci√≥n de comandos y validaci√≥n por test
- Sistema de logging estructurado y logs IA-trazables
- Definici√≥n y registro de 6 metodolog√≠as operativas
- Organizaci√≥n estandarizada de `/docs/` para navegaci√≥n IA

## üîó Relaci√≥n con componentes anteriores

- Contin√∫a la l√≠nea base establecida en `v0.0.0.1`
- Todos los m√≥dulos actuales siguen la metodolog√≠a modular definida
- La arquitectura es ahora indexable y trazable por IA local

üìÇ Ubicaci√≥n recomendada:
`docs/mvp/resumen_mvp_v0.0.0.2.md`
  

### ‚úÖ Alcance logrado

- Se definieron y documentaron 6 metodolog√≠as oficiales:
  - Estructura modular
  - Ciclos de sprint
  - Versionado y backups
  - Documentaci√≥n legible por IA
  - Registro de decisiones (ADR)
  - Interacci√≥n estructurada con sistemas IA

- Todas las metodolog√≠as quedaron reflejadas en:
  - `/docs/01_methodologies/` (activas)
  - `_archivadas/` (anteriores)
  - `_propuestas/` (evoluciones futuras)


### üß© Impacto en el sistema

- Nueva organizaci√≥n del √≠ndice de metodolog√≠as (`Methodology_Index.md`)
- Actualizaci√≥n del `README.md` general
- Preparaci√≥n completa para automatizaci√≥n futura

## Resumen MVP ‚Äì Sprint 2.3

**Objetivo alcanzado:** Consolidaci√≥n y automatizaci√≥n del sistema de metadatos

**Componentes clave:**
- `fix_metadata.py v4`: Generaci√≥n y validaci√≥n autom√°tica de YAML en documentos
- `force_snake_case_modules.py`: Normalizaci√≥n de estructura sem√°ntica para compatibilidad IA
- `validate_docs.py`: Validaci√≥n estricta de integridad documental
- `integrar_nuevo_archivo.sh`: Automatizaci√≥n unificada del flujo de integraci√≥n

**Resultado:**
El sistema de documentaci√≥n cuenta ahora con una base robusta, consistente y lista para escalar con m√≥dulos de IA y procesos colaborativos.


### ‚úÖ Alcance logrado

- Creaci√≥n y estandarizaci√≥n de plantillas en YAML (`docs/estructura_doc`)
- Implementaci√≥n de testing base: CLI y validador de metadatos
- Consolidaci√≥n de documentaci√≥n viva (`TODO.md`, `.project.md`)
- Registro del snapshot con hash SHA y firma t√©cnica
- Organizaci√≥n profesional del sistema documental para escalar con IA


‚úÖ Sprint cerrado formalmente. Documentaci√≥n preparada para expansi√≥n futura.


## üèÅ Consolidaci√≥n del MVP ‚Äì Sprint 2.5

- üì¶ Estructura modular m√≠nima completada
- üìÑ Documentaci√≥n sem√°ntica funcional
- üß† Compatibilidad verificada con modelos IA
- üõ†Ô∏è Validaci√≥n automatizada mediante scripts integrados
- üìö Entrada t√©cnica unificada (`prompt_tecnico_base.md`)
- üß≠ El sistema puede funcionar aut√≥nomamente desde CLI, con IA o como repositorio auditable

> Estado: **MVP estable** ‚Äì listo para evoluci√≥n


module: roadmap_tecnico
type: core
status: in_progress
created: '2025-05-20'
linked_to:
- metodologia_doc_ia_v2.md


## üìå **Fase 1: Desarrollo Inicial (MVP Chat-CLI)**
### Sprint 1 ‚Äì Chat B√°sico + Logs
- [ ] Implementar CLI interactiva con LLM local (`cli.py`).
- [ ] Guardar logs en `.md`/`.json` en `ALMA_RESIST/logs/`.
- [ ] Comandos b√°sicos: `!reset`, `!help`, `!exit`.
- [ ] Pruebas de usabilidad con prompts simples (10+ usuarios beta).
- [ ] **Documentaci√≥n:** Crear `docs/cli_guide.md` (comandos b√°sicos).

### Sprint 2 ‚Äì Persistencia + ALMA_LOADER Inicial
- [ ] Almacenar historial en SQLite cifrado (`user/history.db`).
- [ ] Script ETL diario (`ALMA_LOADER/etl_daily.py`).
- [ ] Comandos: `!memoria [tema]`, `!buscar "[texto]"`.
- [ ] **M√©trica:** Tiempo de respuesta `< 2s` en consultas.


## üìå **Fase 3: Optimizaci√≥n y Escalabilidad**
### Sprint 6 ‚Äì Feedback y Optimizaci√≥n
- [ ] Sistema de feedback: `¬øFue √∫til? [S√≠/No]`.
- [ ] Ajustar sugerencias basadas en `logs/feedback.json`.
- [ ] Refinar prompts del LLM (`ALMA_SERVER_LLM/prompts/`).
- [ ] **Documentaci√≥n:** `docs/feedback_analysis.md`.

### Sprint 7 ‚Äì Integraci√≥n GPU/ONNX
- [ ] Soporte para modelos ONNX en GPU (`llm_onnx.py`).
- [ ] Optimizar inferencia con TensorRT (si NVIDIA GPU detectada).
- [ ] **M√©trica:** `>3x` aceleraci√≥n vs CPU.

### Sprint 8 ‚Äì DuckDB y An√°lisis Avanzado
- [ ] Migrar an√°lisis hist√≥ricos a DuckDB (`ALMA_LOADER/duckdb_analytics.py`).
- [ ] Consultas complejas: `!analizar "uso de RAM √∫ltimos 7 d√≠as"`.
- [ ] **Documentaci√≥n:** `docs/duckdb_integration.md`.

### Sprint 9 ‚Äì Pruebas de Resiliencia
- [ ] Simular corrupci√≥n de logs (`tests/corrupt_logs.py`).
- [ ] Pruebas de inyecci√≥n SQL en bases locales.
- [ ] Validar modo supervivencia bajo estr√©s t√©rmico.
- [ ] **M√©trica:** Recuperaci√≥n en `< 30s` tras fallo.


## üîó **Archivos Relacionados en Obsidian**
- [[ALMA_RESIST-idea_base]]  
- [[ALMA_RESIST-PROMPT_TECNICO]]  
- [[ALMA_RESIST-Whitepaper]]  

### üìé Anexos


-  [[roadmap_tecnico_detallado.pdf|üßæ PDF ‚Äì Roadmap T√©cnico Detallado (v0.0.1)]]




**‚ú® Copia este contenido en un nuevo archivo .md en Obsidian y usa checkboxes ( [ ] ‚Üí [x] ) para marcar el progreso.**

## Archivo: context_tracker_request.md
Contenido:
# üß† Solicitud de Implementaci√≥n ‚Äì `context_tracker.py` ‚Äì Sprint 2.6 ‚Äì ALMA_RESIST

## üéØ Objetivo

Implementar el m√≥dulo `context_tracker.py`, encargado de registrar y mantener un historial contextual estructurado de interacciones en el servidor ALMA_RESIST. Este historial ser√° clave para futuras reflexiones autom√°ticas, reconstrucci√≥n de di√°logos y razonamiento sem√°ntico.


## üß™ Ejemplo de uso

```python
from integration.context_tracker import ContextTracker

tracker = ContextTracker()
tracker.track_interaction("¬øQu√© es la resiliencia?", "La capacidad de...", {"modelo": "mistral"})
historial = tracker.get_history(5)
```

## Archivo: log_writer_request.md
Contenido:
# üß† Solicitud de Implementaci√≥n ‚Äì `log_writer.py` ‚Äì Sprint 2.6 ‚Äì ALMA_RESIST

## üéØ Objetivo

Implementar el m√≥dulo `log_writer.py`, encargado de registrar eventos estructurados del sistema ALMA_RESIST en archivos de log en formato JSONL.

Este m√≥dulo es parte del sistema de trazabilidad segura y debe integrarse con los componentes del servidor LLM.


## üß™ Ejemplo de uso

```python
from utils.log_writer import log_event, write_log

evento = log_event("INFO", "Inicio del servidor LLM", "main")
ok = write_log(evento)
```

## Archivo: main_py_request.md
Contenido:
# üß† Solicitud de Implementaci√≥n ‚Äì `main.py` ‚Äì Sprint 2.6 ‚Äì ALMA_RESIST

## üéØ Objetivo

Implementar el archivo `main.py` del m√≥dulo `llm_server`, que actuar√° como servidor API usando FastAPI. Este archivo forma parte del Sprint 2.6 del proyecto ALMA_RESIST.


## üîß Detalles T√©cnicos

- El archivo debe ubicarse en: `core/llm_server/main.py`
- `ModelWrapper` ya est√° implementado parcialmente en `model_wrapper.py`
- El endpoint debe validar entrada con Pydantic
- No debe haber l√≥gica del modelo en `main.py`, solo orquestaci√≥n


## üß™ Ejemplo de uso

```bash
curl -X POST http://localhost:8000/responder -H "Content-Type: application/json" -d '{"prompt": "¬øQui√©n fue Alan Turing?"}'
```

Esperado:

```json
{
  "respuesta": "Alan Turing fue un matem√°tico brit√°nico considerado el padre de la computaci√≥n moderna..."
}
```


module: prompts/memory_graph_request
type: core
status: in_progress
created: '2025-05-26'
linked_to:
- metodologia_doc_ia_v2.md


## üìò Requisitos

### Clase: `MemoryGraph`

- M√©todos esperados:
  - `add_node(concept: str) -> str`  
    Agrega un nodo √∫nico al grafo sem√°ntico.
  - `create_edge(from_concept: str, to_concept: str, weight: float = 1.0) -> None`  
    Crea una relaci√≥n ponderada entre dos conceptos.
  - `get_related(concept: str, top_k: int = 5) -> list[str]`  
    Recupera los conceptos m√°s relacionados a partir de pesos acumulados.
  - `export_graph(file_path: str) -> None`  
    Exporta el grafo a JSON o GraphML para visualizaci√≥n futura.

### Condiciones:
- Guardar estructura internamente como diccionario `{ nodo: { nodo_vecino: peso } }`
- Prevenir duplicados en nodos
- Incrementar peso si la relaci√≥n ya existe
- Guardar el grafo en archivo local `memory_graph.json`
- Preparado para extender a FAISS o embedding vectorial en el futuro


## üìé Contexto

- Sprint: 2.6 ‚Äì LLM Server
- Integra datos desde: `context_tracker`, `TransportLayer`
- Fundamento del m√≥dulo de reflexi√≥n sem√°ntica de ALMA


module: prompts/model_wrapper_request
type: core
status: in_progress
created: '2025-05-26'
linked_to:
- metodologia_doc_ia_v2.md


## üìò Requisitos

### Clase: `ModelWrapper`

- M√©todos requeridos:
  - `__init__(self, model_path: str, quantization: str = "Q4")`  
    Inicializa el wrapper y prepara configuraci√≥n del modelo.
  - `load_model(self)`  
    Carga el modelo desde el archivo `.gguf` utilizando `llama_cpp.Llama`.
  - `generate(self, prompt: str) -> str`  
    Genera texto a partir de un prompt usando el modelo cargado.
  - `is_loaded(self) -> bool`  
    Devuelve `True` si el modelo est√° cargado correctamente.
  - `get_model_info(self) -> dict`  
    Devuelve un resumen con nombre del modelo, tama√±o del contexto, tokens usados, etc.

### Condiciones:
- Usar la librer√≠a `llama-cpp-python` (`pip install llama-cpp-python`)
- Soportar modelos cuantizados `.gguf`, preferentemente Q4
- Manejar errores si el modelo no est√° cargado
- Ser compatible con FastAPI y asincron√≠a de `main.py` (aunque esta clase puede ser sin `async`)
- Preparar para trabajar con modelos como Mistral 7B o TinyLlama


## üìé Contexto

- Este wrapper ser√° invocado desde el endpoint `/responder` del archivo `main.py`
- Sprint: 2.6 ‚Äì LLM Server
- Arquitectura basada en idea base `0.0.0.4.1`


module: prompts/prompt_add_linked_to_minimo
type: core
status: in_progress
created: '2025-05-23'
linked_to:
- metodologia_doc_ia_v2.md


# üß† Prompt ‚Äì Generador de Script de Correcci√≥n linked_to

Quiero un script en Python llamado `add_linked_to_minimo.py` que recorra todos los archivos `.md` dentro de un directorio (ej: ./docs).

## ‚úÖ El script debe:

1. Leer el bloque YAML de cada archivo.
2. Verificar si el campo `type` es `"core"`.
3. Si el documento **no tiene `linked_to`**, debe agregar:

```yaml
linked_to:
  - metodologia_doc_ia_v2.md
```

4. Mantener los campos existentes. No sobreescribir nada √∫til.
5. Crear un **backup** del archivo antes de modificarlo (guardar en `./backup_linked_to/FECHA/`).
6. Mostrar por consola qu√© archivos fueron modificados.
7. Ignorar los archivos que ya tienen `linked_to`.


## üéØ Objetivo

Este script ayudar√° a corregir m√°s de 90 archivos `.md` que fallan la validaci√≥n por no tener `linked_to`, cuando son `type: core`. El valor `metodologia_doc_ia_v2.md` es un enlace v√°lido y gen√©rico para normalizaci√≥n m√≠nima.


module: prompts/prompt_alma_cli_v0_0_0_4
type: core
status: in_progress
created: '2025-05-26'
linked_to:
- metodologia_doc_ia_v2.md


## üéØ Objetivo del CLI

Centralizar la ejecuci√≥n de todas las tareas de validaci√≥n, reparaci√≥n, estandarizaci√≥n y auditor√≠a sem√°ntica bajo un solo comando:

```bash
python alma-cli.py <comando> [opciones]
```


## üìÅ Estructura esperada

```
alma-cli.py
/docs
/scripts
/logs/auditorias/
    auditoria_YYYYMMDD_HHMM_sprint_X.md
```

module: docs/01_methodologies/metodologia_sprints_v2
type: core
status: in_progress
created: 2025-05-24
linked_to:
  - metodologia_doc_ia_v2.md

## ‚úÖ Reglas de validaci√≥n

- `module` debe reflejar la ruta relativa y estar en snake_case
- `type` debe ser uno de: `core`, `tool`, `external`, `integration`, `draft`
- `status`: `in_progress`, `stable`, `deprecated`
- `created`: formato `YYYY-MM-DD`
- Si `type == core`, `linked_to` es obligatorio
- Si `domain` est√° definido, debe estar tambi√©n en `tags`


## üß™ Ejemplo de uso

```bash
# Validar documentos
python alma-cli.py validate --path ./docs --verbose

# Corregir campos YAML con backup
python alma-cli.py fix-metadata --backup

# Normalizar nombres de m√≥dulo
python alma-cli.py enforce-snakecase

# Agregar linked_to donde falta
python alma-cli.py add-linked-minimo --dry-run

# Ejecutar pipeline completo de limpieza
python alma-cli.py auto-fix --backup --verbose
```


## 1. Reorganizaci√≥n de Secciones

### ‚úÖ Cambio
Mover la secci√≥n üìÅ Estructura esperada antes de ‚öôÔ∏è Subcomandos a integrar.

### üí° Justificaci√≥n
Ayuda a contextualizar la estructura de archivos antes de describir los comandos que interact√∫an con ella, mejorando la coherencia l√≥gica.


### ‚úçÔ∏è Mejora en `batch-update`
A√±adir ejemplo de uso:

```bash
# Actualizar campos en lote (ej: a√±adir `domain` a todos los archivos de tipo `core`)
python alma-cli.py batch-update --filter-type core --set-field domain:ai --dry-run
```

**Justificaci√≥n:** Clarifica el uso avanzado del comando y su flexibilidad.


## 4. Documentaci√≥n de Dependencias

### ‚ûï Secci√≥n: üì¶ Dependencias

```markdown
## üì¶ Dependencias
- `PyYAML` para an√°lisis de bloques YAML.
- `python-slugify` para normalizar snake_case.
```

**Justificaci√≥n:** Informa a los desarrolladores sobre las bibliotecas externas requeridas, evitando errores de importaci√≥n.


## 6. Ejemplos Completos

### ‚ûï Ejemplo para `report`

```bash
# Generar informe en formato JSON
python alma-cli.py report --output-format json
```

**Justificaci√≥n:** Demuestra c√≥mo usar salidas alternativas (JSON) para integraci√≥n con otras herramientas.


## 8. Extensibilidad del Proyecto

### ‚ûï Nota: Contribuir

```markdown
> üí° **Contribuir**: Este CLI es modular. Para a√±adir nuevos subcomandos, implemente funciones en `/scripts` y reg√≠strelas en `alma-cli.py`.
```

**Justificaci√≥n:** Fomenta la colaboraci√≥n y extensi√≥n del proyecto por parte de la comunidad.

## Archivo: prompt_base_cli_modular_v2.md
Contenido:
# üß† Prompt T√©cnico ‚Äì CLI Modular ALMA_RESIST (v2, sin cmd.Cmd)


## ‚öôÔ∏è Requisitos funcionales

- Al ejecutar `python core/cli.py`, debe iniciarse un prompt tipo:
  ```
  alma>
  ```
- El usuario puede ingresar comandos como:
  - `!ayuda`
  - `!salir`
  - `!resumir "texto"`
  - `!buscar_memoria "tag"`
- Cada comando se define como una funci√≥n externa en un archivo separado dentro de `commands/`.


## üîß Requisitos t√©cnicos

- `core/cli.py` debe actuar como un **router** de comandos:
  - Lee entrada del usuario (`input`)
  - Separa comando (`!comando`) de argumentos
  - Busca en un diccionario cargado din√°micamente desde `commands/`
  - Ejecuta la funci√≥n `run(args)` correspondiente
- Si el comando no existe, debe mostrar un mensaje de error.
- Debe incluir comando `!ayuda` que imprima los comandos disponibles (basado en las claves del router).


## üîê Restricciones

- **No usar `cmd.Cmd`, argparse, click ni frameworks externos.**
- Todo debe funcionar con funciones planas (`def run(args):`)
- El sistema debe ser extensible: para agregar un comando, basta con crear un archivo `.py` con funci√≥n `run(args)`.


## üß† En resumen

Implementar un CLI minimalista, s√≥lido y extensible para ALMA_RESIST, basado en arquitectura modular y sin dependencias m√°gicas. Este CLI debe estar listo para integrarse a IA local, logs y memoria a futuro.


module: prompts/prompt_chat_0_0_1
type: core
status: in_progress
created: '2025-05-17'
linked_to:
- metodologia_doc_ia_v2.md


## üß≠ Instrucci√≥n Final para GPT-4.5

Como IA Copiloto, desarroll√° un roadmap t√©cnico **usando `ALMA_LIBRE/` e `idea_base_0.0.9.md` como base conceptual, no estructural**. Tu tarea incluye:

1. **Roadmap t√©cnico realista (3‚Äì6 meses)**  
   - Sprint por sprint (tablas markdown con hiperv√≠nculos)  
   - Subtareas de 2‚Äì4h con justificaciones t√©cnicas  

2. **Validaci√≥n multiplataforma y por arquitectura**  
   - x86_64, ARMv8, RISC-V  
   - Script `test_arch.sh` detecta y ejecuta tests optimizados  
   - Reporte comparativo en `docs/benchmarks_arch.md`

3. **Pol√≠ticas de energ√≠a avanzadas**  
   - `taskset`, `cpufreq-set`, I/O throttling  
   - Activaci√≥n autom√°tica por condiciones: bater√≠a <15%, CPU >80¬∞C, swap >20%  
   - Desactivaci√≥n de m√≥dulos no cr√≠ticos  

4. **Monitoreo predictivo en tiempo real**  
   - `alma_monitor.py`: alertas por RAM, temperatura, uso de CPU  
   - IA que propone mitigaciones autom√°ticas

5. **Autoevaluaci√≥n y aprendizaje evolutivo**  
   - `alma_auto_eval.py`: compara m√©tricas entre sprints  
   - IA genera sugerencias + benchmarks + pr√≥ximos pasos  

6. **Integraci√≥n de tecnolog√≠as emergentes (roadmap ONNX/TensorRT)**  
   - Sprint 6: Wrapper C++ GPU, validaci√≥n de precisi√≥n  
   - Sprint 7: Quantizaci√≥n din√°mica, soporte NPU con OpenVINO  

7. **Simulaciones extremas**  
   - Corrupci√≥n de logs + headers ilegibles  
   - SQL injection sint√©tica  
   - P√©rdida de refrigeraci√≥n ‚Üí modo survival 30% CPU  
   - Fallo 2/3 nodos de cluster (evaluar degradaci√≥n)

8. **Documentaci√≥n inteligente y ejecutable**  
   - `docs/reporte_sprint.md`: KPIs, gr√°ficos interactivos Plotly, c√≥digo rastreable  
   - `docs/lecciones_aprendidas.md`: refactors, fallos, herramientas descartadas  
   - `docs/arquitectura_evolutiva.md`: c√≥mo integrar nuevas tecnolog√≠as sin romper compatibilidad

9. **Migraci√≥n y actualizaci√≥n autom√°tica**  
   - Script `alma_update.sh` para mover config/logs/versiones  
   - Checklist retrocompatibilidad (versi√≥n previa a actual)


## üîê Detalles T√©cnicos Clave

- üõ†Ô∏è `test_arch.sh`: Detecta arquitectura y lanza pruebas optimizadas
- üìà `alma_monitor.py`: RAM, CPU, disco, temperatura ‚Üí alertas
- üß† `alma_auto_eval.py`: An√°lisis entre sprints, IA sugiere cambios
- üß™ `generate_synthetic_data.py`: 10k mensajes, modelos rotos, ataques sint√©ticos
- üîÑ `alma_update.sh`: Migraci√≥n de configuraciones entre versiones

