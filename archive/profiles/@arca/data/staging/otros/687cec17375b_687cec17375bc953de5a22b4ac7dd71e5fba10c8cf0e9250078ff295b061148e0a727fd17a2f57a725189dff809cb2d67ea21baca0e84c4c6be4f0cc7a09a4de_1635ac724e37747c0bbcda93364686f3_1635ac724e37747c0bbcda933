# ğŸ§  memoria_saver.py â€“ Guardado robusto con rollback y estado

"""
Este mÃ³dulo implementa una funciÃ³n `guardar_memoria(memoria: dict)` con control de errores, estado y sincronizaciÃ³n entre SQLite y FAISS.

Requisitos:
1. Validar que el input cumple con `schema_base.json` (usar validador externo).
2. Intentar guardar primero en SQLite (usando `sqlite_storage.py`)
3. Luego guardar el vector en FAISS (usando `vector_storage.py`)
4. Si FAISS falla:
   - Registrar el error
   - Actualizar el campo `"estado"` de la memoria a `"pendiente_vectorizaciÃ³n"`
   - Mantener el registro en SQLite
5. Si SQLite falla:
   - Cancelar el proceso y no insertar nada
   - Devolver estado `"error"` y mensaje
6. Registrar logs estructurados con `logging` o `structlog`.
7. Aplicar `try/except` por cada capa
8. El retorno debe ser un diccionario con:
   - `"resultado"`: "ok" o "error"
   - `"estado"`: estado final de la memoria
   - `"mensaje"`: breve explicaciÃ³n
9. Compatibilidad futura con `on_memoria_guardada()` y `HookManager`.

Dependencias internas:
- `sqlite_storage.insertar_memoria()`
- `vector_storage.vectorizar_y_guardar()`
- `validador.validar_esquema()`
- `cifrado.cifrar_contenido()`
"""

# ğŸ“Œ FunciÃ³n principal: guardar_memoria(memoria: dict) -> dict
# Validar â†’ Cifrar si es privada â†’ Guardar en SQLite â†’ Guardar vector en FAISS â†’ actualizar estado

# âš ï¸ El mÃ³dulo no debe depender de frameworks externos ni de FastAPI (autÃ³nomo para usar en backend o terminal).
