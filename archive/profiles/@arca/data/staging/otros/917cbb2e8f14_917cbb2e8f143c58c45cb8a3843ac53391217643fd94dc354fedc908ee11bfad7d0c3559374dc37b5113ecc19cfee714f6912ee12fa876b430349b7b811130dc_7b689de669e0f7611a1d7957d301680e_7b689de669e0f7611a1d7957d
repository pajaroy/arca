import pytest
import json
import uuid
from pathlib import Path
from datetime import datetime, timedelta
from transport_layer import TransportLayer
import jsonschema
import logging

# Fixtures para contratos mock
@pytest.fixture(scope="module")
def mock_contracts(tmp_path_factory):
    contracts_dir = tmp_path_factory.mktemp("contracts")

    # Crear esquemas mock
    prompt_schema = {
        "type": "object",
        "properties": {
            "prompt": {"type": "string"},
            "context": {"type": "array"}
        },
        "required": ["prompt"]
    }

    respuesta_schema = {
        "type": "object",
        "properties": {
            "respuesta": {"type": "string"},
            "metadata": {"type": "object"}
        },
        "required": ["respuesta"]
    }

    (contracts_dir / "schema_prompt.json").write_text(json.dumps(prompt_schema))
    (contracts_dir / "schema_respuesta.json").write_text(json.dumps(respuesta_schema))

    return contracts_dir

# Fixture principal para TransportLayer
@pytest.fixture
def transport(mock_contracts, tmp_path):
    return TransportLayer(contracts_dir=str(mock_contracts))

# Tests de validación de datos
def test_send_valid_prompt(transport, tmp_path):
    test_data = {"prompt": "Test válido", "context": []}
    transport.send(test_data, "responder")

    files = list(tmp_path.glob("transport_data/responder_*.json"))
    assert len(files) == 1, "Debe crear un archivo"

    content = json.loads(files[0].read_text())
    assert content == test_data, "Contenido no coincide"

def test_send_invalid_prompt(transport, caplog):
    with pytest.raises(jsonschema.ValidationError):
        transport.send({"invalid": "data"}, "responder")

    assert "Validación fallida" in caplog.text

# Tests de recuperación de datos
def test_receive_last_entry(transport):
    test_data = {"prompt": "Test1"}
    transport.send(test_data, "responder")

    test_data2 = {"prompt": "Test2"}
    transport.send(test_data2, "responder")

    result = transport.receive("responder")
    assert result == test_data2, "Debe recuperar último archivo"

# Tests de listado y rotación
def test_list_entries_ordering(transport):
    for i in range(3):
        data = {"prompt": f"Test{i}"}
        transport.send(data, "responder")

    entries = transport.list_entries("responder")
    assert len(entries) == 3, "Debe listar todos los archivos"

    timestamps = [e.stem.split("_")[1] for e in entries]
    assert timestamps == sorted(timestamps, reverse=True), "Orden incorrecto"

def test_purge_old_entries(transport):
    for _ in range(5):
        transport.send({"prompt": "Test"}, "responder")

    transport.purge_old_entries("responder", max_files=2)
    remaining = transport.list_entries("responder")
    assert len(remaining) == 2, "Debe mantener solo los últimos 2"

# Tests de infraestructura
def test_directory_creation(transport, tmp_path):
    assert (tmp_path / "transport_data").exists(), "Debe crear directorio base"

def test_missing_contracts():
    with pytest.raises(RuntimeError) as excinfo:
        TransportLayer(contracts_dir="invalid/path")

    assert "Contracts not loaded" in str(excinfo.value)

# Tests de formato de archivo
def test_filename_format(transport):
    test_data = {"prompt": "Test"}
    transport.send(test_data, "responder")

    files = transport.list_entries("responder")
    filename = files[0].name
    parts = filename.split("_")

    assert len(parts) == 3, "Formato incorrecto"
    assert parts[0] == "responder", "Endpoint mal identificado"
    assert len(parts[1]) == 14, "Timestamp inválido"
    assert len(parts[2].split(".")[0]) == 6, "UUID corto inválido"

# Test de validación cruzada
def test_send_response_schema(transport):
    valid_response = {"respuesta": "OK", "metadata": {}}
    transport.send(valid_response, "otro_endpoint")

    files = transport.list_entries("otro_endpoint")
    assert len(files) == 1, "Debe usar schema respuesta"

# Test de persistencia
def test_data_persistence(transport, tmp_path):
    test_data = {"prompt": "Persistencia Test"}
    transport.send(test_data, "responder")

    new_transport = TransportLayer(contracts_dir=transport.contracts)
    loaded_data = new_transport.receive("responder")
    assert loaded_data == test_data, "Persistencia fallida"

# Test de archivos corruptos
def test_corrupted_file_handling(transport, caplog):
    file = transport.base_dir / "corrupt.json"
    file.write_text("{invalid: json}")

    assert transport.receive("corrupt") is None
    assert "Error en receive" in caplog.text

# Limpieza de archivos temporales
@pytest.fixture(autouse=True)
def cleanup(tmp_path):
    yield
    transport_dir = tmp_path / "transport_data"
    if transport_dir.exists():
        for f in transport_dir.glob("*.json"):
            f.unlink()
