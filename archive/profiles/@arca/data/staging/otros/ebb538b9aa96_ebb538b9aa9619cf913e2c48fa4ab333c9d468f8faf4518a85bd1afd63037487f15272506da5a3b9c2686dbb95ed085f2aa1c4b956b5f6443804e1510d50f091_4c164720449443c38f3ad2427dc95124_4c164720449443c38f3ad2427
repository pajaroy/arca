import os
import logging
import tempfile
import subprocess
from telegram import Update
from telegram.ext import Application, MessageHandler, filters, ContextTypes
import whisper

# Configuraci√≥n b√°sica de logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# Cargar modelo Whisper una sola vez al iniciar
model = whisper.load_model("base")

async def handle_audio(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Manejador de mensajes de audio y voz"""
    try:
        # Crear directorio temporal √∫nico para cada proceso
        with tempfile.TemporaryDirectory() as tmp_dir:
            file_id, file_ext = await get_file_id(update)
            if not file_id:
                return

            # Descargar archivo
            input_path = await download_file(file_id, tmp_dir, update, file_ext)
            
            # Convertir a WAV
            wav_path = await convert_to_wav(input_path, tmp_dir)
            
            # Transcribir con Whisper
            transcription = transcribe_audio(wav_path)
            
            # Enviar respuesta
            await send_transcription(update, transcription)

    except Exception as e:
        logger.error(f"Error procesando audio: {str(e)}")
        await update.message.reply_text("‚ùå Error procesando el audio. Por favor intenta nuevamente.")

async def get_file_id(update: Update):
    """Obtiene el file_id seg√∫n el tipo de mensaje"""
    if update.message.voice:
        return update.message.voice.file_id, "ogg"
    elif update.message.audio:
        return update.message.audio.file_id, update.message.audio.file_name.split('.')[-1]
    return None, None

async def download_file(file_id: str, tmp_dir: str, update: Update, file_ext: str):
    """Descarga el archivo de Telegram"""
    file = await update.message.effective_attachment.get_file()
    input_path = os.path.join(tmp_dir, f"audio_{file_id}.{file_ext}")
    await file.download_to_drive(input_path)
    return input_path

async def convert_to_wav(input_path: str, tmp_dir: str):
    """Convierte el audio a formato WAV usando FFmpeg"""
    wav_path = os.path.join(tmp_dir, "audio.wav")
    cmd = [
        'ffmpeg',
        '-i', input_path,
        '-ar', '16000',
        '-ac', '1',
        '-y',
        wav_path
    ]
    subprocess.run(cmd, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    return wav_path

def transcribe_audio(wav_path: str):
    """Ejecuta la transcripci√≥n con Whisper"""
    result = model.transcribe(wav_path, fp16=False)
    return result["text"]

async def send_transcription(update: Update, text: str):
    """Env√≠a la transcripci√≥n al grupo"""
    max_length = 4000
    parts = [text[i:i+max_length] for i in range(0, len(text), max_length)]
    
    for part in parts:
        mensaje = f"üé§ Transcripci√≥n:\n\n{part}"
        await update.message.reply_text(
            mensaje,
            reply_to_message_id=update.message.message_id
        )

def main():
    """Inicializaci√≥n del bot"""
    token = "7666744025:AAFo3iiw9loASRl5AyaDK7zqr-HUnwTxwLQ"
    
    application = Application.builder().token(token).build()
    application.add_handler(MessageHandler(
        filters.VOICE | filters.AUDIO,
        handle_audio
    ))
    
    logger.info("Iniciando bot...")
    application.run_polling()

if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        logger.error(f"Error cr√≠tico: {str(e)}")
        raise
