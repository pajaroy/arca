Para abordar el problema, implementamos la función `guardar_memoria` siguiendo los requisitos paso a paso, asegurando validación, cifrado, guardado robusto en SQLite y FAISS, manejo de errores y actualización de estados. Aquí está la solución:

python

Copy

Download

import copy
import logging
from validador import validar_esquema
from sqlite_storage import insertar_memoria
from vector_storage import vectorizar_y_guardar
from cifrado import cifrar_contenido

# Configuración básica de logging
logger = logging.getLogger(__name__)

def guardar_memoria(memoria: dict) -> dict:
    resultado = {
        "resultado": "error",
        "estado": "error",
        "mensaje": ""
    }

    # 1. Validación del esquema
    try:
        validar_esquema(memoria, 'schema_base.json')
    except Exception as e:
        logger.error(f"Error de validación: {str(e)}", extra={"memoria_id": memoria.get('id')})
        resultado["mensaje"] = f"Error de validación: {str(e)}"
        return resultado

    # 2. Cifrado de contenido si es privada
    try:
        if memoria.get('privada', False):
            memoria_para_sql = copy.deepcopy(memoria)
            contenido_cifrado = cifrar_contenido(memoria_para_sql['contenido'])
            memoria_para_sql['contenido'] = contenido_cifrado
        else:
            memoria_para_sql = copy.deepcopy(memoria)
    except KeyError as e:
        logger.error(f"Campo faltante: {str(e)}", extra={"memoria_id": memoria.get('id')})
        resultado["mensaje"] = "El campo 'contenido' es requerido"
        return resultado
    except Exception as e:
        logger.error(f"Error al cifrar: {str(e)}", extra={"memoria_id": memoria.get('id')})
        resultado["mensaje"] = f"Error de cifrado: {str(e)}"
        return resultado

    # 3. Guardado en SQLite
    try:
        insertar_memoria(memoria_para_sql)
    except Exception as e:
        logger.error(f"Error en SQLite: {str(e)}", extra={"memoria_id": memoria.get('id')})
        resultado["mensaje"] = f"Error en SQLite: {str(e)}"
        return resultado

    # 4. Vectorización y guardado en FAISS
    estado_final = memoria_para_sql.get('estado', 'completado')
    mensaje = "Guardado exitoso en SQLite y FAISS"
    try:
        vectorizar_y_guardar(memoria_para_sql)
    except Exception as e:
        logger.error(f"Error en FAISS: {str(e)}", extra={"memoria_id": memoria.get('id')})
        
        # Actualizar estado en SQLite
        try:
            memoria_actualizada = copy.deepcopy(memoria_para_sql)
            memoria_actualizada['estado'] = 'pendiente_vectorización'
            insertar_memoria(memoria_actualizada)
            estado_final = 'pendiente_vectorización'
            mensaje = "FAISS falló. Estado actualizado a pendiente_vectorización."
        except Exception as e2:
            logger.error(f"Error actualizando estado: {str(e2)}", extra={"memoria_id": memoria.get('id')})
            mensaje = "FAISS falló. No se pudo actualizar el estado."

    # Preparar respuesta final
    resultado["resultado"] = "ok"
    resultado["estado"] = estado_final
    resultado["mensaje"] = mensaje

    return resultado

**Explicación:**

1. **Validación del esquema:** Se utiliza el validador para asegurar que la memoria cumple con el esquema base. Si falla, se retorna error inmediatamente.
    
2. **Cifrado condicional:** Si la memoria es privada, se cifra el contenido usando una copia profunda para no modificar el original.
    
3. **Guardado en SQLite:** Se intenta guardar en SQLite primero. Si falla, se retorna error.
    
4. **Vectorización en FAISS:** Si el guardado en FAISS falla:
    
    - Se actualiza el estado de la memoria a "pendiente_vectorización".
        
    - Se intenta actualizar el registro en SQLite con el nuevo estado.
        
    - Si esta actualización falla, se registra el error pero se mantiene el estado como pendiente en la respuesta.
        
5. **Manejo de errores granular:** Cada capa (validación, cifrado, SQLite, FAISS) tiene su propio bloque try/except para un manejo preciso de errores.
    
6. **Logs estructurados:** Se utiliza logging para registrar errores con contexto relevante (ID de memoria cuando está disponible).
    
7. **Retorno consistente:** Siempre se retorna un diccionario con el formato especificado, indicando el resultado, estado final y mensaje descriptivo.