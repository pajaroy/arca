import os
import json
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Optional, Dict, Any

logger = logging.getLogger(__name__)

class LogWriter:
    LOG_DIR = Path("logs")
    LOG_DIR.mkdir(parents=True, exist_ok=True)

    @staticmethod
    def log_event(type: str, message: str, module: str = "core", metadata: Optional[Dict[str, Any]] = None) -> Dict:
        if not isinstance(message, str):
            raise TypeError("El campo 'message' debe ser str")
        if metadata is not None and not isinstance(metadata, dict):
            raise TypeError("El campo 'metadata' debe ser un dict si se proporciona")

        return {
            "timestamp": datetime.utcnow().isoformat() + "Z",
            "type": type.lower(),
            "module": module,
            "message": message,
            "pid": os.getpid(),
            "host": os.uname().nodename,
            "platform": os.uname().sysname + "-" + os.uname().release,
            "metadata": metadata or {}
        }

    def _get_log_path(self) -> Path:
        date_str = datetime.utcnow().strftime("%Y-%m-%d")
        return self.LOG_DIR / f"alma_{date_str}.log"

    def write_log(self, event: Dict) -> bool:
        log_path = self._get_log_path()
        temp_path = log_path.with_suffix(".tmp")

        try:
            if not all(key in event for key in ("timestamp", "type", "message")):
                raise ValueError("Evento mal formado")

            line = json.dumps(event, ensure_ascii=False) + "\n"

            with open(temp_path, "a", encoding="utf-8") as f:
                f.write(line)

            os.replace(temp_path, log_path)
            logger.debug(f"Evento registrado: {event['type']} ({event['module']})")
            return True

        except (IOError, OSError) as e:
            logger.error(f"Error escribiendo log: {str(e)}")
            try:
                if temp_path.exists():
                    temp_path.unlink()
            except:
                pass
            return False

        except ValueError as e:
            logger.warning(f"Evento inv√°lido: {str(e)}")
            return False

    @classmethod
    def secure_rotation(cls, days: int = 7):
        cutoff = datetime.utcnow() - timedelta(days=days)
        for file in cls.LOG_DIR.glob("alma_*.log"):
            try:
                date_str = file.stem.split("_")[1]
                file_date = datetime.strptime(date_str, "%Y-%m-%d")
                if file_date < cutoff:
                    file.unlink()
            except Exception as e:
                logger.warning(f"No se pudo rotar {file}: {str(e)}")