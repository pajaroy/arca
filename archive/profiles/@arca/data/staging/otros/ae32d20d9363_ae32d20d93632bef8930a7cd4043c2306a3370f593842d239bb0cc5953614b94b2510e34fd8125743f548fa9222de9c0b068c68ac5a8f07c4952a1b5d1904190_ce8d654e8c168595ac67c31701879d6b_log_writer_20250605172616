import os
import json
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Optional, Dict, Any

logger = logging.getLogger(__name__)
DEFAULT_LOG_DIR = Path.cwd() / "logs"

class LogWriter:
    def __init__(self, log_dir: Optional[str] = None):
        self.log_dir = Path(log_dir) if log_dir else DEFAULT_LOG_DIR
        self.log_dir.mkdir(parents=True, exist_ok=True)

    @staticmethod
    def log_event(event_type: str, message: Any, module: str = "core", metadata: Optional[Dict[str, Any]] = None) -> Dict:
        if not isinstance(message, str):
            message = str(message)
        if metadata is not None and not isinstance(metadata, dict):
            raise TypeError("El campo 'metadata' debe ser un dict si se proporciona")

        return {
            "timestamp": datetime.utcnow().isoformat() + "Z",
            "type": event_type.lower(),
            "module": module,
            "message": message,
            "pid": os.getpid(),
            "host": os.uname().nodename,
            "platform": os.uname().sysname + "-" + os.uname().release,
            "metadata": metadata or {}
        }

    def _get_log_path(self) -> Path:
        date_str = datetime.utcnow().strftime("%Y-%m-%d")
        return self.log_dir / f"alma_{date_str}.log"

    def write_log(self, event: Dict) -> bool:
        log_path = self._get_log_path()
        temp_path = log_path.with_suffix(".tmp")

        try:
            if not all(key in event for key in ("timestamp", "type", "message")):
                raise ValueError("Evento mal formado")

            line = json.dumps(event, ensure_ascii=False) + "\n"
            with open(temp_path, "a", encoding="utf-8") as f:
                f.write(line)

            if log_path.exists():
                with open(log_path, "a", encoding="utf-8") as f_main, open(temp_path, "r", encoding="utf-8") as f_temp:
                    f_main.write(f_temp.read())
                os.remove(temp_path)
            else:
                os.rename(temp_path, log_path)

            logger.debug(f"Evento registrado: {event['type']} ({event['module']})")
            return True

        except (IOError, OSError) as e:
            logger.error(f"Error escribiendo log: {str(e)}")
            try:
                if temp_path.exists():
                    os.remove(temp_path)
            except:
                pass
            return False

        except ValueError as e:
            logger.warning(f"Evento inv√°lido: {str(e)}")
            return False

    def secure_rotation(self, days: int = 7):
        cutoff = datetime.utcnow() - timedelta(days=days)
        for file in self.log_dir.glob("alma_*.log"):
            try:
                date_str = file.stem.split("_")[1]
                file_date = datetime.strptime(date_str, "%Y-%m-%d")
                if file_date < cutoff:
                    file.unlink()
            except Exception as e:
                logger.warning(f"No se pudo rotar {file}: {str(e)}")
