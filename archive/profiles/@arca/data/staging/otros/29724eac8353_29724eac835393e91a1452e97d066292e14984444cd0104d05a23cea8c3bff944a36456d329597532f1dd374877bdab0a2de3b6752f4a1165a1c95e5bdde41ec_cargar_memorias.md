

```python
import argparse
import json
import os
import sys
from typing import List, Dict, Any

try:
    import yaml
except ImportError:
    print("Falta pyyaml. Instalá con: pip install pyyaml")
    sys.exit(1)

def cargar_archivo(path: str) -> List[Dict[str, Any]]:
    if not os.path.exists(path):
        return []
    with open(path, "r", encoding="utf-8") as f:
        if path.endswith(".json"):
            return json.load(f)
        elif path.endswith(".yaml") or path.endswith(".yml"):
            return yaml.safe_load(f) or []
        else:
            raise Exception("Formato no soportado.")

def guardar_archivo(path: str, data: List[Dict[str, Any]]):
    with open(path, "w", encoding="utf-8") as f:
        if path.endswith(".json"):
            json.dump(data, f, indent=2, ensure_ascii=False)
        elif path.endswith(".yaml") or path.endswith(".yml"):
            yaml.safe_dump(data, f, allow_unicode=True)
        else:
            raise Exception("Formato no soportado.")

def main():
    parser = argparse.ArgumentParser(description="Cargar memorias a la base institucional ALMA_RESIST.")
    parser.add_argument("--input", required=True, help="Archivo con memorias a cargar (JSON o YAML)")
    parser.add_argument("--dest", required=True, help="Archivo destino (memorias.json/yaml o bitacora_viva.json/yaml)")

    args = parser.parse_args()

    # Cargar memorias nuevas
    with open(args.input, "r", encoding="utf-8") as f:
        if args.input.endswith(".json"):
            nuevas = json.load(f)
        elif args.input.endswith(".yaml") or args.input.endswith(".yml"):
            nuevas = yaml.safe_load(f)
        else:
            raise Exception("Solo se aceptan archivos JSON o YAML")

    if isinstance(nuevas, dict):  # Si es un solo registro
        nuevas = [nuevas]

    # Cargar destino existente o iniciar vacío
    base = cargar_archivo(args.dest)

    # Unificar y evitar duplicados por 'id'
    ids_existentes = {m["id"] for m in base if "id" in m}
    agregadas, rechazadas = 0, 0
    for mem in nuevas:
        if mem.get("id") in ids_existentes:
            print(f"[!] Duplicado, no se carga: {mem.get('id')}")
            rechazadas += 1
        else:
            base.append(mem)
            ids_existentes.add(mem.get("id"))
            agregadas += 1

    # Guardar destino actualizado
    guardar_archivo(args.dest, base)
    print(f"[+] Memorias agregadas: {agregadas}")
    print(f"[-] Rechazadas (duplicadas): {rechazadas}")

if __name__ == "__main__":
    main()
```

¿Qué hace y qué NO hace?

    ✅ Carga de registros nuevos, evita duplicados, admite JSON y YAML.

    ✅ Corre desde cualquier ruta, mientras le des los paths correctos.

    ❌ No hace validación de campos ni logging ni backup.

    ❌ No soporta batch por stdin, ni locks, ni flags avanzados.

Siguiente paso

    Guardá el script como cargar_memorias.py.

    Probalo con una memoria de ejemplo y revisá el resultado en el archivo destino.

    Cuando quieras escalar, versionás este script o le vas sumando features.

