import os
import sys
import logging
import uuid
from pathlib import Path
from ruamel.yaml import YAML
from ruamel.yaml.comments import CommentedMap
from datetime import datetime, timezone
from io import StringIO

# ------------------------------------------------------------
# NUEVO: Configuración de logging centralizada
# ------------------------------------------------------------

LOG_FILE = "/home/alma/Alma-Cli/Logs/fix_metadata.log"

# Asegura que exista el directorio de logs
os.makedirs(os.path.dirname(LOG_FILE), exist_ok=True)

logging.basicConfig(
    filename=LOG_FILE,
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)
logger = logging.getLogger('metadata_validator')

# ------------------------------------------------------------
# NUEVO: función centralizada para print + log
# ------------------------------------------------------------

def log_and_print(msg):
    print(msg)
    logger.info(msg)

# ------------------------------------------------------------
# NUEVO: función para volcar YAML a string
# ------------------------------------------------------------

def dump_yaml_to_string(data):
    """
    Serializa un objeto YAML a string usando ruamel.yaml
    """
    yaml = YAML()
    yaml.preserve_quotes = True
    yaml.indent(mapping=2, sequence=4, offset=2)
    stream = StringIO()
    yaml.dump(data, stream)
    return stream.getvalue()

# ------------------------------------------------------------
# Plantilla ALMA_RESIST
# ------------------------------------------------------------

PLANTILLA = CommentedMap({
    "version": "0.1.0",
    "uuid": "",
    "tipo": "",
    "schema": "",
    "estado": "",
    "descripcion": "",
    "estructura": [""],
    "tags": [],
    "linked_to": [],
    "responsable": "",
    "hash_verificacion": "sha256:pending",
    "historial": [{"fecha": "", "descripcion": ""}],
    "last_modified": "",
    "last_modified_by": ""
})

ORDER = [
    "version", "uuid", "tipo", "schema", "estado", "descripcion",
    "estructura", "tags", "linked_to", "responsable",
    "hash_verificacion", "historial", "last_modified", "last_modified_by"
]

# ------------------------------------------------------------
# NUEVO: Validar que el frontmatter sea serializable
# ------------------------------------------------------------

def validate_frontmatter(data):
    """
    Devuelve True si el frontmatter cargado es serializable sin errores.
    """
    try:
        _ = dump_yaml_to_string(data)
        return True
    except Exception as e:
        logger.error(f"Frontmatter inválido: {str(e)}")
        return False

# ------------------------------------------------------------
# NUEVO: Aplicar plantilla SOLO a campos faltantes
# ------------------------------------------------------------

def aplicar_plantilla(existente=None, force_update=False, user="unknown"):
    """
    Devuelve metadatos ALMA_RESIST, completando solo los campos faltantes,
    y respetando valores existentes si no se fuerza actualización.
    """
    nuevo = CommentedMap()

    for key in ORDER:
        if existente and key in existente and not force_update:
            nuevo[key] = existente[key]
        else:
            nuevo[key] = PLANTILLA[key]

    # --------------------------------------------------------
    # NUEVO: Generar UUID solo si está vacío
    # --------------------------------------------------------
    if not nuevo["uuid"]:
        nuevo["uuid"] = str(uuid.uuid4())

    # --------------------------------------------------------
    # NUEVO: Completar campos dinámicos solo si no existen
    # --------------------------------------------------------
    if not nuevo["last_modified"] or force_update:
        nuevo["last_modified"] = datetime.now(timezone.utc).isoformat()

    if not nuevo["last_modified_by"] or force_update:
        nuevo["last_modified_by"] = user

    return nuevo

# ------------------------------------------------------------
# Procesar Markdown (.md)
# ------------------------------------------------------------

def procesar_markdown(contenido, force_update, user):
    yaml = YAML()
    yaml.preserve_quotes = True

    # Verificar si ya tiene frontmatter
    if contenido.startswith('---\n'):
        partes = contenido.split('---\n', 2)
        if len(partes) >= 3:
            metadata_str = partes[1]
            restante = '---\n'.join(partes[2:])

            try:
                metadata = yaml.load(metadata_str) or CommentedMap()
                
                if validate_frontmatter(metadata):
                    if "version" in metadata and not force_update:
                        # --------------------------------------------------
                        # PARCHE: no tocar frontmatter existente
                        # --------------------------------------------------
                        log_and_print("✓ Metadata ya presente. No se modifica.")
                        return contenido, False
                    else:
                        # Forzar actualización
                        nuevo_metadata = aplicar_plantilla(metadata, force_update, user)
                        salida = "---\n"
                        salida += dump_yaml_to_string(nuevo_metadata)
                        salida += "---\n" + restante
                        return salida, True
                else:
                    # Frontmatter inválido → se recrea
                    nuevo_metadata = aplicar_plantilla(None, True, user)
                    salida = "---\n"
                    salida += dump_yaml_to_string(nuevo_metadata)
                    salida += "---\n" + restante
                    return salida, True
            except Exception as e:
                logger.error(f"Error procesando YAML: {str(e)}")
                nuevo_metadata = aplicar_plantilla(None, True, user)
                salida = "---\n" + dump_yaml_to_string(nuevo_metadata) + "---\n" + contenido
                return salida, True

    else:
        # No tiene frontmatter → se crea
        nuevo_metadata = aplicar_plantilla(None, False, user)
        salida = "---\n"
        salida += dump_yaml_to_string(nuevo_metadata)
        salida += "---\n\n" + contenido
        return salida, True

# ------------------------------------------------------------
# Procesar YAML puro (.yaml/.yml)
# ------------------------------------------------------------

def procesar_yaml(contenido, force_update, user):
    yaml = YAML()
    yaml.preserve_quotes = True
    yaml.indent(mapping=2, sequence=4, offset=2)

    try:
        metadata = yaml.load(contenido) or CommentedMap()

        if validate_frontmatter(metadata):
            if "version" in metadata and not force_update:
                log_and_print("✓ Metadata ya presente. No se modifica.")
                return contenido, False
            else:
                nuevo_metadata = aplicar_plantilla(metadata, force_update, user)
                return dump_yaml_to_string(nuevo_metadata), True
        else:
            nuevo_metadata = aplicar_plantilla(None, True, user)
            return dump_yaml_to_string(nuevo_metadata), True
    except Exception as e:
        logger.error(f"Error procesando YAML: {str(e)}")
        nuevo_metadata = aplicar_plantilla(None, True, user)
        return dump_yaml_to_string(nuevo_metadata), True

# ------------------------------------------------------------
# Función principal
# ------------------------------------------------------------

def validar_metadata(path: str, force_update: bool = False) -> None:
    """
    Valida y repara metadatos YAML en archivos .md o .yaml según ALMA_RESIST
    """
    user = os.getenv("USER", "unknown")

    try:
        if not os.path.exists(path):
            with open(path, 'w', encoding='utf-8') as f:
                pass
            log_and_print(f"Archivo creado: {path}")
            contenido = ""
        else:
            with open(path, 'r', encoding='utf-8') as f:
                contenido = f.read()

        nombre_archivo = os.path.basename(path)
        ext = os.path.splitext(nombre_archivo)[1].lower()

        if ext == '.md':
            nuevo_contenido, modificado = procesar_markdown(contenido, force_update, user)
        elif ext in ('.yaml', '.yml'):
            nuevo_contenido, modificado = procesar_yaml(contenido, force_update, user)
        else:
            log_and_print(f"✗ Error: Extensión no soportada - {nombre_archivo}")
            return

        if modificado or not contenido.strip():
            with open(path, 'w', encoding='utf-8') as f:
                f.write(nuevo_contenido)
            log_and_print(f"✓ Metadata {'creada' if not contenido.strip() else 'actualizada'} en {nombre_archivo}")
        else:
            log_and_print(f"✓ Metadata ya completa en {nombre_archivo}")

    except Exception as e:
        error_msg = f"✗ Error procesando {path}: {str(e)}"
        log_and_print(error_msg)

# ------------------------------------------------------------
# CLI
# ------------------------------------------------------------

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Uso: python validador_metadata.py <ruta_archivo> [--force]")
        sys.exit(1)

    archivo = sys.argv[1]
    force = False

    if len(sys.argv) > 2 and sys.argv[2] == "--force":
        force = True

    validar_metadata(archivo, force)
