# ğŸ§  Prompt TÃ©cnico ALMA_LOADER v3.0
## A. Roadmap TÃ©cnico (por fases)
### Fase 1 â€“ Core estable
- Registro estructurado
- ValidaciÃ³n con JSON Schema
- Guardado en SQLite
- ResÃºmenes diarios

### Fase 2 â€“ SemÃ¡ntico
- Embeddings de contenido + FAISS
- Router atencional
- AnÃ¡lisis predictivo simple
- Relaciones entre memorias

### Fase 3 â€“ ExpansiÃ³n
- GamificaciÃ³n, metas y refuerzos
- Sistema de reglas con acciones encadenadas
- IntegraciÃ³n con apps externas (API REST, Telegram, Shortcuts, voz)

## 1. PropÃ³sito del Sistema
Este prompt define todas las funciones tÃ©cnicas, estructuras internas y flujos de interacciÃ³n del sistema ALMA_LOADER. Su objetivo es que cualquier modelo IA o humano tÃ©cnico pueda ejecutar, extender o auditar el sistema con claridad total. Consolidado a partir de versiones 2.1.1 y 2.2.0.

## 2. MÃ³dulos Funcionales
- `core_nl.py` â€“ ConversiÃ³n NL â†’ JSON mediante reglas y patrones
- `validador.py` â€“ ValidaciÃ³n con `schema_base.json` y normalizaciÃ³n de campos
- `sqlite_storage.py` â€“ Almacenamiento actual, optimizado con JSON1 para consultas internas
- `base_storage.py` â€“ Interfaz abstracta de almacenamiento compatible con mÃºltiples motores
- `vector_storage.py` â€“ BÃºsqueda semÃ¡ntica con embeddings vÃ­a FAISS (alpha)
- `router_atencional.py` â€“ Enrutamiento segÃºn intenciÃ³n detectada (acciÃ³n, reflexiÃ³n, memoria)
- `resumenes.py` â€“ GeneraciÃ³n de resumen en Markdown diario o semanal
- `alma_analytics.py` â€“ DetecciÃ³n de patrones, correlaciones y disparadores
- `gamificacion.py` â€“ Sistema de motivaciÃ³n por puntos, niveles y hÃ¡bitos (fase 3)

Los mÃ³dulos de ALMA_LOADER estÃ¡n diseÃ±ados para ser independientes y fÃ¡cilmente intercambiables. A continuaciÃ³n, se indican las principales tecnologÃ­as asociadas a cada uno:

### ğŸ› ï¸ TecnologÃ­as Utilizadas por MÃ³dulo

| MÃ³dulo                   | TecnologÃ­a / Herramienta              |
|--------------------------|--------------------------------------|
| NLP / Parsing            | `regex`, `spaCy` (plan futuro)       |
| VectorizaciÃ³n semÃ¡ntica | `sentence-transformers`, `FAISS`     |
| Almacenamiento           | `SQLite` (con JSON1), `FAISS` (alpha)|
| VisualizaciÃ³n / Testing  | `pytest`, `Mermaid` (para diagramas) |
| Relaciones semÃ¡nticas    | `dict`, relaciones cruzadas (`Neo4j`, `networkx` â€“ futuro) |


## 3. JSON Schema de Memoria
```json
{
  "id": "MEM-TRD-2025-XXXX",
  "categoria": "TRD",
  "contenido": "texto plano",
  "tags": ["#btc", "#reflexiÃ³n"],
  "resumen_inferido": "...",
  "embedding_id": "EMB-abc123",
  "vector": [0.123, 0.987, ...],
  "intencion_detectada": "registro",
  "origen_input": "usuario",
  "relaciones": [
    { "tipo": "temporal", "target_id": "MEM-TRD-2025-XXXX", "peso": 0.8 }
  ]
}
```

> Este prompt tÃ©cnico permite que cualquier IA ejecute acciones correctas dentro de ALMA_LOADER sin ambigÃ¼edades ni errores de interpretaciÃ³n. Complementa al whitepaper 3.0 (explicativo y estratÃ©gico).

## 9. Testing y Validaciones

### ğŸ§ª Test Unitario â€“ ValidaciÃ³n de Memoria

Este test permite verificar que el esquema base JSON acepte estructuras vÃ¡lidas y rechace incorrectas. Se usa como prueba mÃ­nima para `validador.py`.

```python
def test_validar_memoria():
    memoria_valida = {
        "id": "MEM-TRD-2025-05-06-001",
        "categoria": "TRD",
        "contenido": "Hoy operÃ© en BTC y me sentÃ­ confiado",
        "tags": ["#btc", "#emociÃ³n:confianza"]
    }
    assert validar_esquema(memoria_valida) == True
```

Este tipo de test puede ejecutarse con `pytest`, `unittest`, o integrarse en un pipeline de verificaciÃ³n previa al guardado.

### ğŸ§ª Test Unitario â€“ VectorizaciÃ³n SemÃ¡ntica

Este test valida que la funciÃ³n de embeddings estÃ© operativa y produzca un vector vÃ¡lido (usualmente de 384 o 768 dimensiones, segÃºn modelo).

```python
def test_vectorizacion():
    texto = "Hoy operÃ© bajo presiÃ³n y me sentÃ­ impulsivo."
    vector = generar_embedding(texto)
    
    assert isinstance(vector, list)
    assert len(vector) >= 128
    assert all(isinstance(x, float) for x in vector)
```

> Este test puede servir tanto para debug local como para verificar integridad del motor FAISS en producciÃ³n.

## 10. Relaciones entre Memorias â€“ Grafo Dirigido

ALMA_LOADER permite establecer vÃ­nculos explÃ­citos entre memorias usando el campo `relaciones`. Esto habilita un grafo dirigido de conocimiento interno.

Cada relaciÃ³n incluye:
- `tipo`: naturaleza de la relaciÃ³n (ej: `temporal`, `causal`, `emocional`, `refuerzo`)
- `target_id`: ID de la memoria relacionada
- `peso`: valor entre 0 y 1 que indica la fuerza del vÃ­nculo

### ğŸ“„ Ejemplo:
```json
"relaciones": [
  { "tipo": "causal", "target_id": "MEM-TRD-2025-05-04-002", "peso": 0.85 },
  { "tipo": "temporal", "target_id": "MEM-TRD-2025-05-03-001", "peso": 0.6 }
]
```

Este grafo puede analizarse para:
- Descubrir patrones encadenados (causas â†’ consecuencias)
- Medir recurrencia o acumulaciÃ³n emocional
- Visualizar el recorrido mental de un tema

### ğŸ› ï¸ Futuras integraciones:
- `networkx` (Python) para anÃ¡lisis de grafos
- `Neo4j` para persistencia de relaciones complejas
- Mermaid o D3.js para visualizaciÃ³n grÃ¡fica

> El objetivo es pasar de registros aislados a una red dinÃ¡mica de aprendizaje personal.
