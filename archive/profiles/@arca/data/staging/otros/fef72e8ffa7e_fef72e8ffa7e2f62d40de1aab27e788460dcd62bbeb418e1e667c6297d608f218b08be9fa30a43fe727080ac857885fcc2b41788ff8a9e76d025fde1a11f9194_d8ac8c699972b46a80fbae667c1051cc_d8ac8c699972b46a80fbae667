import pytest
import json
from pathlib import Path
from datetime import datetime
from context_tracker import ContextTracker
import logging
import os

# Fixture principal con archivo temporal
@pytest.fixture
def tracker(tmp_path):
    storage_path = tmp_path / "test_context.jsonl"
    return ContextTracker(storage_path=str(storage_path))

# Test de registro básico
def test_track_valid_interaction(tracker):
    test_data = {
        "prompt": "Test válido",
        "response": "Respuesta OK",
        "metadata": {"model": "test"}
    }

    result = tracker.track_interaction(**test_data)
    assert result is not None, "Debe registrar interacción válida"

    with open(tracker.storage_path, "r") as f:
        line = json.loads(f.readline())
        assert line["prompt"] == test_data["prompt"]
        assert line["response"] == test_data["response"]

# Test de validación de esquema
def test_invalid_interaction(tracker, caplog):
    invalid_data = {"prompt": "Test inválido"}
    result = tracker.track_interaction(**invalid_data)

    assert result is None, "No debe registrar interacción inválida"
    assert "Contexto inválido" in caplog.text

# Test de recuperación de historial
def test_get_history_ordering(tracker):
    for i in range(5):
        tracker.track_interaction(
            prompt=f"Prompt {i}",
            response=f"Response {i}",
            metadata={"order": i}
        )

    history = tracker.get_history(3)
    assert len(history) == 3, "Debe devolver los últimos 3 registros"
    assert history[0]["metadata"]["order"] == 4, "Último registro primero"
    assert history[-1]["metadata"]["order"] == 2, "Tercer registro último"

# Test de manejo de archivo corrupto
def test_corrupted_file_handling(tracker, caplog):
    with open(tracker.storage_path, "a") as f:
        f.write("{invalid_json}\n")

    tracker.track_interaction(prompt="Test", response="OK")

    history = tracker.get_history()
    assert len(history) == 1, "Debe ignorar línea corrupta"
    assert "Línea corrupta" in caplog.text

# Test de borrado de historial
def test_clear_history(tracker):
    tracker.track_interaction(prompt="Test", response="OK")
    tracker.clear_history()

    assert len(tracker) == 0, "Historial debe estar vacío"
    assert tracker.storage_path.exists(), "Archivo debe recrearse"

    with open(tracker.storage_path, "r") as f:
        assert f.read() == "", "Archivo debe quedar vacío"

# Test de longitud del historial
def test_history_length(tracker):
    for _ in range(5):
        tracker.track_interaction(prompt="Test", response="OK")

    assert len(tracker) == 5, "Longitud incorrecta"

    with open(tracker.storage_path, "a") as f:
        f.write("corrupt_data\n")

    assert len(tracker) == 5, "Debe ignorar líneas corruptas"

# Test de permisos de archivo
def test_file_permissions(tracker):
    tracker.track_interaction(prompt="Test", response="OK")
    assert oct(tracker.storage_path.stat().st_mode)[-3:] == "600", "Permisos inseguros"

# Test de persistencia entre instancias
def test_persistence_across_instances(tmp_path):
    storage_path = tmp_path / "persistence_test.jsonl"

    tracker1 = ContextTracker(storage_path=str(storage_path))
    tracker1.track_interaction(prompt="Test1", response="OK")

    tracker2 = ContextTracker(storage_path=str(storage_path))
    history = tracker2.get_history()

    assert len(history) == 1, "Debe persistir entre instancias"
    assert history[0]["prompt"] == "Test1"

# Test de límite de caché
def test_cache_limit(tracker):
    for _ in range(150):
        tracker.track_interaction(prompt="Test", response="OK")

    assert len(tracker._history_cache) == 100, "Caché debe rotar"

# Limpieza de registros
@pytest.fixture(autouse=True)
def cleanup(tracker):
    yield
    if tracker.storage_path.exists():
        tracker.storage_path.unlink()
