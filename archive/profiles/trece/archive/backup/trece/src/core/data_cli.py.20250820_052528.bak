"""
version: 0.1.0
descripcion: terminal cli funcional anda todo bien
"""
import cmd
import csv
import os
import sys
from datetime import datetime, date
from collections import defaultdict

class TreceCLI(cmd.Cmd):
    intro = """
    \033[1;32m
      _______  _____  _____  ______ 
     |__   __|/ ____|/ ____||  ____|
        | |  | |    | |     | |__   
        | |  | |    | |     |  __|  
        | |  | |____| |____ | |____ 
        |_|   \_____|\_____||______|
    \033[0m
    Terminal de Gestión de Datos - Versión 1.0
    Escribe 'help' para ver los comandos disponibles.
    """
    prompt = '\033[1;34mdata_cli> \033[0m'
    
    def __init__(self):
        super().__init__()
        self.data_dir = "data"
        self.load_data()
        
    def load_data(self):
        """Carga todos los archivos CSV desde el directorio data"""
        self.data = {}
        try:
            for filename in os.listdir(self.data_dir):
                if filename.endswith('.csv'):
                    name = filename[:-4]  # Remove .csv extension
                    filepath = os.path.join(self.data_dir, filename)
                    with open(filepath, 'r', encoding='utf-8') as f:
                        reader = csv.DictReader(f)
                        self.data[name] = list(reader)
            print("\033[1;32m✓ Datos cargados correctamente\033[0m")
        except Exception as e:
            print(f"\033[1;31m✗ Error cargando datos: {e}\033[0m")
    
    def do_reload(self, arg):
        """Recargar datos sin salir del terminal"""
        self.load_data()
    
    def do_balance_mes_actual(self, arg):
        """Cálculo de balance del mes actual"""
        try:
            current_month = datetime.now().month
            current_year = datetime.now().year
            
            # Calcular ingresos (retiros)
            ingresos = 0
            for retiro in self.data.get('withdrawals', []):
                fecha = datetime.strptime(retiro['date'], '%Y-%m-%d')
                if fecha.month == current_month and fecha.year == current_year:
                    # Buscar el precio correspondiente
                    precio_id = retiro['price_id']
                    precio = next((p for p in self.data.get('prices', []) 
                                  if p['id'] == precio_id), None)
                    if precio:
                        total_retiro = float(retiro['grams']) * float(precio['amount'])
                        ingresos += total_retiro
            
            # Calcular gastos
            gastos = 0
            for gasto in self.data.get('expenses', []):
                fecha = datetime.strptime(gasto['date'], '%Y-%m-%d')
                if fecha.month == current_month and fecha.year == current_year:
                    gastos += float(gasto['amount'])
            
            balance = ingresos - gastos
            
            print("\n" + "="*50)
            print("\033[1;36mBALANCE DEL MES ACTUAL\033[0m")
            print("="*50)
            print(f"Ingresos: \033[1;32m${ingresos:,.2f}\033[0m")
            print(f"Gastos: \033[1;31m${gastos:,.2f}\033[0m")
            print(f"Balance: \033[1;34m${balance:,.2f}\033[0m")
            print("="*50)
            
        except Exception as e:
            print(f"\033[1;31mError calculando balance: {e}\033[0m")
    
    def do_dashboard_mensual(self, arg):
        """Resumen mensual con métricas clave"""
        try:
            current_month = datetime.now().month
            current_year = datetime.now().year
            
            # Inicializar métricas
            ingresos_totales = 0
            gastos_totales = 0
            retiros_por_socio = defaultdict(float)
            gastos_por_categoria = defaultdict(float)
            
            # Procesar retiros (ingresos)
            for retiro in self.data.get('withdrawals', []):
                fecha = datetime.strptime(retiro['date'], '%Y-%m-%d')
                if fecha.month == current_month and fecha.year == current_year:
                    precio_id = retiro['price_id']
                    precio = next((p for p in self.data.get('prices', []) 
                                  if p['id'] == precio_id), None)
                    if precio:
                        total_retiro = float(retiro['grams']) * float(precio['amount'])
                        ingresos_totales += total_retiro
                        
                        # Acumular por socio
                        socio_id = retiro['entitie_id']
                        socio = next((s for s in self.data.get('entities', []) 
                                     if s['id'] == socio_id), {'name': 'Desconocido'})
                        retiros_por_socio[socio['name']] += total_retiro
            
            # Procesar gastos
            for gasto in self.data.get('expenses', []):
                fecha = datetime.strptime(gasto['date'], '%Y-%m-%d')
                if fecha.month == current_month and fecha.year == current_year:
                    monto = float(gasto['amount'])
                    gastos_totales += monto
                    
                    # Acumular por concepto
                    concepto_id = gasto['concept_id']
                    concepto = next((c for c in self.data.get('concepts', []) 
                                    if c['id'] == concepto_id), {'name': 'Desconocido'})
                    gastos_por_categoria[concepto['name']] += monto
            
            balance = ingresos_totales - gastos_totales
            
            # Mostrar dashboard
            print("\n" + "="*60)
            print("\033[1;36mDASHBOARD MENSUAL\033[0m")
            print("="*60)
            print(f"Período: {current_month}/{current_year}")
            print(f"Ingresos Totales: \033[1;32m${ingresos_totales:,.2f}\033[0m")
            print(f"Gastos Totales: \033[1;31m${gastos_totales:,.2f}\033[0m")
            print(f"Balance Neto: \033[1;34m${balance:,.2f}\033[0m")
            print("-"*60)
            
            print("\n\033[1;33mRetiros por Socio:\033[0m")
            for socio, monto in sorted(retiros_por_socio.items(), key=lambda x: x[1], reverse=True):
                print(f"  {socio}: ${monto:,.2f}")
            
            print("\n\033[1;33mGastos por Categoría:\033[0m")
            for categoria, monto in sorted(gastos_por_categoria.items(), key=lambda x: x[1], reverse=True):
                print(f"  {categoria}: ${monto:,.2f}")
            
            print("="*60)
            
        except Exception as e:
            print(f"\033[1;31mError generando dashboard: {e}\033[0m")
    
    def do_gastos_por_entidad_y_concepto(self, arg):
        """Agrupación de gastos por entidad y concepto"""
        try:
            gastos_agrupados = defaultdict(lambda: defaultdict(float))
            
            for gasto in self.data.get('expenses', []):
                entidad_id = gasto['entitie_id']
                concepto_id = gasto['concept_id']
                monto = float(gasto['amount'])
                
                # Obtener nombres
                entidad = next((e for e in self.data.get('entities', []) 
                               if e['id'] == entidad_id), {'name': 'Desconocido'})
                concepto = next((c for c in self.data.get('concepts', []) 
                                if c['id'] == concepto_id), {'name': 'Desconocido'})
                
                gastos_agrupados[entidad['name']][concepto['name']] += monto
            
            # Mostrar resultados
            print("\n" + "="*70)
            print("\033[1;36mGASTOS POR ENTIDAD Y CONCEPTO\033[0m")
            print("="*70)
            
            for entidad, conceptos in gastos_agrupados.items():
                print(f"\n\033[1;33m{entidad}:\033[0m")
                total_entidad = sum(conceptos.values())
                for concepto, monto in sorted(conceptos.items(), key=lambda x: x[1], reverse=True):
                    print(f"  {concepto}: ${monto:,.2f}")
                print(f"  \033[1;35mTotal: ${total_entidad:,.2f}\033[0m")
            
            print("="*70)
            
        except Exception as e:
            print(f"\033[1;31mError agrupando gastos: {e}\033[0m")
    
    def do_harvest_stock(self, arg):
        """Gestión de stock de cosechas"""
        try:
            # Calcular stock por genética
            stock_genetica = defaultdict(float)
            
            for detalle in self.data.get('harvest_detail', []):
                genetic_id = detalle['genetic_id']
                grams = float(detalle['grams'])
                
                # Restar retiros
                genetic_retiros = sum(
                    float(r['grams']) for r in self.data.get('withdrawals', [])
                    if r['genetic_id'] == genetic_id
                )
                
                net_grams = grams - genetic_retiros
                if net_grams > 0:
                    genetic_name = next(
                        (g['name'] for g in self.data.get('genetics', [])
                        if g['id'] == genetic_id), f"Genética {genetic_id}"
                    )
                    stock_genetica[genetic_name] += net_grams
            
            # Mostrar stock
            print("\n" + "="*50)
            print("\033[1;36mSTOCK DE COSECHAS\033[0m")
            print("="*50)
            
            if not stock_genetica:
                print("No hay stock disponible")
            else:
                for genetic, grams in sorted(stock_genetica.items()):
                    print(f"{genetic}: {grams:,.2f} gramos")
            
            print("="*50)
            
        except Exception as e:
            print(f"\033[1;31mError calculando stock: {e}\033[0m")
    
    def do_retiros_por_socio(self, arg):
        """Análisis de retiros por socio"""
        try:
            retiros_por_socio = defaultdict(float)
            
            for retiro in self.data.get('withdrawals', []):
                socio_id = retiro['entitie_id']
                precio_id = retiro['price_id']
                grams = float(retiro['grams'])
                
                # Obtener precio
                precio = next((p for p in self.data.get('prices', []) 
                              if p['id'] == precio_id), {'amount': '0'})
                monto = grams * float(precio['amount'])
                
                # Obtener nombre del socio
                socio = next((s for s in self.data.get('entities', []) 
                             if s['id'] == socio_id), {'name': f'Socio {socio_id}'})
                
                retiros_por_socio[socio['name']] += monto
            
            # Mostrar resultados
            print("\n" + "="*50)
            print("\033[1;36mRETIROS POR SOCIO\033[0m")
            print("="*50)
            
            total_retiros = sum(retiros_por_socio.values())
            for socio, monto in sorted(retiros_por_socio.items(), key=lambda x: x[1], reverse=True):
                porcentaje = (monto / total_retiros) * 100 if total_retiros > 0 else 0
                print(f"{socio}: ${monto:,.2f} ({porcentaje:.1f}%)")
            
            print("-"*50)
            print(f"\033[1;35mTOTAL: ${total_retiros:,.2f}\033[0m")
            print("="*50)
            
        except Exception as e:
            print(f"\033[1;31mError analizando retiros: {e}\033[0m")
    
    def do_stock_actual(self, arg):
        """Consulta de stock actualizado"""
        try:
            # Calcular stock total por genética
            stock = defaultdict(float)
            
            # Sumar todas las cosechas
            for detalle in self.data.get('harvest_detail', []):
                genetic_id = detalle['genetic_id']
                grams = float(detalle['grams'])
                stock[genetic_id] += grams
            
            # Restar todos los retiros
            for retiro in self.data.get('withdrawals', []):
                genetic_id = retiro['genetic_id']
                grams = float(retiro['grams'])
                stock[genetic_id] -= grams
            
            # Mostrar resultados
            print("\n" + "="*60)
            print("\033[1;36mSTOCK ACTUAL\033[0m")
            print("="*60)
            
            total_stock = 0
            for genetic_id, grams in stock.items():
                if grams > 0:
                    genetic_name = next(
                        (g['name'] for g in self.data.get('genetics', [])
                        if g['id'] == genetic_id), f"Genética {genetic_id}"
                    )
                    print(f"{genetic_name}: {grams:,.2f} gramos")
                    total_stock += grams
            
            print("-"*60)
            print(f"\033[1;35mSTOCK TOTAL: {total_stock:,.2f} gramos\033[0m")
            print("="*60)
            
        except Exception as e:
            print(f"\033[1;31mError consultando stock: {e}\033[0m")
    
    def do_sum_expenses(self, arg):
        """Sumatoria de gastos"""
        try:
            total = 0
            for gasto in self.data.get('expenses', []):
                total += float(gasto['amount'])
            
            print(f"\n\033[1;36mSUMATORIA DE GASTOS: \033[1;31m${total:,.2f}\033[0m\n")
            
        except Exception as e:
            print(f"\033[1;31mError sumando gastos: {e}\033[0m")
    
    def do_sum_withdrawals(self, arg):
        """Sumatoria de retiros"""
        try:
            total = 0
            for retiro in self.data.get('withdrawals', []):
                precio_id = retiro['price_id']
                grams = float(retiro['grams'])
                
                precio = next((p for p in self.data.get('prices', []) 
                              if p['id'] == precio_id), {'amount': '0'})
                total += grams * float(precio['amount'])
            
            print(f"\n\033[1;36mSUMATORIA DE RETIROS: \033[1;32m${total:,.2f}\033[0m\n")
            
        except Exception as e:
            print(f"\033[1;31mError sumando retiros: {e}\033[0m")
    
    def do_help(self, arg):
        """Sistema de ayuda integrado"""
        help_text = """
\033[1;36mCOMANDOS DISPONIBLES:\033[0m

  \033[1;33mbalance_mes_actual\033[0m      - Cálculo de balance del mes actual
  \033[1;33mdashboard_mensual\033[0m       - Resumen mensual con métricas clave
  \033[1;33mgastos_por_entidad_y_concepto\033[0m - Agrupación de gastos
  \033[1;33mharvest_stock\033[0m           - Gestión de stock de cosechas
  \033[1;33mretiros_por_socio\033[0m       - Análisis de retiros por socio
  \033[1;33mstock_actual\033[0m            - Consulta de stock actualizado
  \033[1;33msum_expenses\033[0m            - Sumatoria de gastos
  \033[1;33msum_withdrawals\033[0m         - Sumatoria de retiros
  \033[1;33mreload\033[0m                  - Recargar datos sin salir del terminal
  \033[1;33mhelp\033[0m                    - Mostrar esta ayuda
  \033[1;33mexit\033[0m                    - Salir del terminal
"""
        print(help_text)
    
    def do_exit(self, arg):
        """Salir del terminal"""
        print("\033[1;32m¡Hasta pronto!\033[0m")
        return True
    
    def do_quit(self, arg):
        """Salir del terminal"""
        return self.do_exit(arg)
    
    def emptyline(self):
        """No hacer nada cuando se presiona Enter sin comando"""
        pass

if __name__ == '__main__':
    # Verificar que existe el directorio data
    if not os.path.exists('data'):
        print("\033[1;31mError: No se encuentra el directorio 'data'\033[0m")
        print("Asegúrate de que el directorio existe y contiene los archivos CSV necesarios.")
        sys.exit(1)
    
    # Iniciar terminal
    cli = TreceCLI()
    cli.cmdloop()